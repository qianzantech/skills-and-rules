{
  "rules": {
    "frontend": [
      {
        "fullPath": "rules/frontend/typescript",
        "filename": "RULE.md",
        "name": "typescript",
        "category": "frontend",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: TypeScript coding standards and best practices for modern development. Apply when writing TypeScript code in any project.\r\nglobs: \"**/*.ts, **/*.tsx, **/*.d.ts\"\r\n---\r\n\r\n# TypeScript Best Practices\r\n\r\n## Type System\r\n\r\n- Prefer `interface` over `type` for object definitions\r\n- Use `type` for unions, intersections, and mapped types\r\n- **Avoid `any`** - prefer `unknown` for unknown types\r\n- Enable strict mode in `tsconfig.json`\r\n- Leverage built-in utility types (`Partial`, `Required`, `Pick`, `Omit`, `Record`)\r\n\r\n## Naming Conventions\r\n\r\n| Type | Convention | Example |\r\n|------|------------|---------|\r\n| Interface/Type | PascalCase | `UserProfile`, `ApiResponse` |\r\n| Variable/Function | camelCase | `getUserData`, `isLoading` |\r\n| Constant | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `API_BASE_URL` |\r\n| Enum values | PascalCase | `UserRole.Admin` |\r\n\r\n## Functions\r\n\r\n```typescript\r\n// Explicit return type for public functions\r\nexport function calculateTotal(items: CartItem[]): number {\r\n  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\r\n}\r\n\r\n// Arrow function with proper typing\r\nconst formatDate = (date: Date, locale: string = 'en-US'): string => {\r\n  return new Intl.DateTimeFormat(locale).format(date);\r\n};\r\n```\r\n\r\n## Best Practices\r\n\r\n- Use `readonly` for immutable properties\r\n- Leverage discriminated unions for type safety\r\n- Use type guards for runtime type checking\r\n- Implement proper null checking with `?.` and `??`\r\n- Avoid type assertions (`as`) unless necessary\r\n\r\n## Configuration\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"noImplicitAny\": true,\r\n    \"strictNullChecks\": true,\r\n    \"noImplicitReturns\": true\r\n  }\r\n}\r\n```",
        "files": []
      },
      {
        "fullPath": "rules/frontend/uniapp",
        "filename": "RULE.md",
        "name": "uniapp",
        "category": "frontend",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: UniApp development guidelines for cross-platform mobile/mini-program applications. Apply when developing with UniApp framework.\r\nglobs: \"**/*.vue, **/pages/**/*.vue, **/components/**/*.vue, manifest.json, pages.json\"\r\n---\r\n\r\n# UniApp Development Guidelines\r\n\r\n## Overview\r\n\r\nUniApp is a cross-platform framework that allows you to develop once and deploy to:\r\n- **H5** (Web)\r\n- **WeChat/Alipay/Baidu Mini Programs**\r\n- **iOS/Android Apps**\r\n\r\n## Project Structure\r\n\r\n```\r\n├── pages/                 # Page components\r\n│   └── index/\r\n│       └── index.vue\r\n├── components/            # Reusable components\r\n├── static/               # Static assets (images, fonts)\r\n├── store/                # Vuex/Pinia store\r\n├── utils/                # Utility functions\r\n├── api/                  # API request modules\r\n├── uni_modules/          # UniApp plugins\r\n├── App.vue               # App entry component\r\n├── main.js               # Entry file\r\n├── manifest.json         # App configuration\r\n├── pages.json            # Page routing configuration\r\n└── uni.scss              # Global SCSS variables\r\n```\r\n\r\n## Vue 3 Composition API (UniApp 3.x)\r\n\r\n```vue\r\n<script setup>\r\nimport { ref, computed, onMounted } from 'vue'\r\n\r\nconst count = ref(0)\r\nconst doubleCount = computed(() => count.value * 2)\r\n\r\nonMounted(() => {\r\n  console.log('Page mounted')\r\n})\r\n\r\n// UniApp lifecycle hooks\r\nonLoad((options) => {\r\n  console.log('Page loaded with options:', options)\r\n})\r\n\r\nonShow(() => {\r\n  console.log('Page shown')\r\n})\r\n</script>\r\n```\r\n\r\n## Responsive Design (rpx)\r\n\r\n```scss\r\n// Use rpx for responsive units (750rpx = screen width)\r\n.container {\r\n  width: 750rpx;      // Full width\r\n  padding: 30rpx;     // ~15px on 375px screen\r\n  font-size: 28rpx;   // ~14px on 375px screen\r\n}\r\n```\r\n\r\n## Platform-Specific Code\r\n\r\n```vue\r\n<template>\r\n  <view>\r\n    <!-- #ifdef MP-WEIXIN -->\r\n    <button open-type=\"getUserInfo\">微信登录</button>\r\n    <!-- #endif -->\r\n    \r\n    <!-- #ifdef H5 -->\r\n    <button @click=\"h5Login\">H5登录</button>\r\n    <!-- #endif -->\r\n    \r\n    <!-- #ifdef APP-PLUS -->\r\n    <button @click=\"appLogin\">App登录</button>\r\n    <!-- #endif -->\r\n  </view>\r\n</template>\r\n```\r\n\r\n## Navigation\r\n\r\n```javascript\r\nuni.navigateTo({ url: '/pages/detail/detail?id=123' })\r\nuni.redirectTo({ url: '/pages/login/login' })\r\nuni.switchTab({ url: '/pages/index/index' })\r\nuni.navigateBack({ delta: 1 })\r\n```\r\n\r\n## Common UI Patterns\r\n\r\n```javascript\r\nuni.showLoading({ title: '加载中...' })\r\nuni.hideLoading()\r\n\r\nuni.showToast({ title: '操作成功', icon: 'success' })\r\n\r\nuni.showModal({\r\n  title: '提示',\r\n  content: '确定要删除吗？',\r\n  success: (res) => {\r\n    if (res.confirm) { /* confirmed */ }\r\n  }\r\n})\r\n```\r\n\r\n## Best Practices\r\n\r\n1. **Use rpx** for responsive sizing (750rpx = full screen width)\r\n2. **Use conditional compilation** (`#ifdef`) for platform-specific code\r\n3. **Check component support** in UniApp docs before using\r\n4. **Handle API errors** with proper user feedback\r\n5. **Use uni-ui** components for cross-platform compatibility\r\n6. **Test on multiple platforms** (WeChat DevTools, H5, App simulator)\r\n7. **Avoid direct DOM manipulation** - use data binding\r\n8. **Use pages.json** for page configuration",
        "files": []
      }
    ],
    "general": [
      {
        "fullPath": "rules/general/clean-code",
        "filename": "RULE.md",
        "name": "clean-code",
        "category": "general",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: Clean code principles for writing maintainable and human-readable code. Apply during code writing and review.\r\nglobs: \"**/*\"\r\n---\r\n\r\n# Clean Code Guidelines\r\n\r\n## Constants Over Magic Numbers\r\n\r\n```typescript\r\n// Bad\r\nif (retryCount > 3) { }\r\nconst timeout = 86400000\r\n\r\n// Good\r\nconst MAX_RETRY_COUNT = 3\r\nconst ONE_DAY_MS = 24 * 60 * 60 * 1000\r\n\r\nif (retryCount > MAX_RETRY_COUNT) { }\r\nconst timeout = ONE_DAY_MS\r\n```\r\n\r\n## Meaningful Names\r\n\r\n```typescript\r\n// Bad\r\nconst d = new Date()\r\nconst u = users.filter(x => x.a)\r\n\r\n// Good\r\nconst createdDate = new Date()\r\nconst activeUsers = users.filter(user => user.isActive)\r\n```\r\n\r\n## Single Responsibility\r\n\r\n- Each function should do exactly one thing\r\n- Functions should be small and focused\r\n- If a function needs a comment to explain what it does, split it\r\n\r\n## DRY (Don't Repeat Yourself)\r\n\r\n- Extract repeated code into reusable functions\r\n- Share common logic through proper abstraction\r\n- Maintain single sources of truth\r\n\r\n## Smart Comments\r\n\r\n- Don't comment what code does - make code self-documenting\r\n- Comment **why** something is done a certain way\r\n- Document APIs and non-obvious side effects\r\n\r\n## Encapsulation\r\n\r\n- Hide implementation details\r\n- Expose clear interfaces\r\n- Move nested conditionals into well-named functions\r\n\r\n## Checklist\r\n\r\n- [ ] No magic numbers - use named constants\r\n- [ ] All names are meaningful and descriptive\r\n- [ ] Comments explain \"why\" not \"what\"\r\n- [ ] Each function has single responsibility\r\n- [ ] No repeated code - DRY principle followed",
        "files": []
      },
      {
        "fullPath": "rules/general/coding-standards",
        "filename": "RULE.md",
        "name": "coding-standards",
        "category": "general",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: General coding standards and guidelines. Apply to all code reviews and development tasks.\r\nglobs: \"**/*\"\r\n---\r\n\r\n# Coding Standards\r\n\r\n## Core Principles\r\n\r\n- **Verify information** before presenting it\r\n- **Preserve existing code** - don't remove unrelated code\r\n- **Use explicit variable names** - prefer descriptive over short\r\n- **Follow existing coding style** - maintain consistency\r\n- **Consider security** - always think about security implications\r\n- **Handle edge cases** - consider and handle potential edge cases\r\n\r\n## AI Agent Behavior Rules\r\n\r\n### Do's\r\n- Make changes file by file\r\n- Provide all edits in a single chunk per file\r\n- Use explicit, descriptive variable names\r\n- Follow consistent coding style\r\n- Include appropriate unit tests\r\n- Implement robust error handling\r\n\r\n### Don'ts\r\n- No apologies in code or comments\r\n- No whitespace-only changes unless requested\r\n- No unnecessary confirmations of provided information\r\n- No inventions beyond what's explicitly requested\r\n- No summaries unless asked\r\n- No implementation discussions unless requested\r\n\r\n## Performance\r\n\r\n```typescript\r\n// Use early returns\r\nfunction processItem(item: Item | null): Result {\r\n  if (!item) return null\r\n  if (!item.isValid) return null\r\n  return process(item)\r\n}\r\n\r\n// Use appropriate data structures\r\nconst userMap = new Map<string, User>()  // O(1) lookup\r\nconst uniqueIds = new Set<string>()       // O(1) membership\r\n```\r\n\r\n## Documentation\r\n\r\n- Don't comment **what** - make code self-documenting\r\n- Comment **why** something is done a certain way\r\n- Document APIs and non-obvious side effects\r\n\r\n## Version Control\r\n\r\n- Write clear, descriptive commit messages\r\n- Make small, focused commits\r\n- Use meaningful branch names\r\n\r\n## Checklist\r\n\r\n- [ ] No magic numbers or strings\r\n- [ ] Meaningful variable and function names\r\n- [ ] Functions have single responsibility\r\n- [ ] No code duplication\r\n- [ ] Proper error handling\r\n- [ ] Edge cases considered\r\n- [ ] Tests included for new functionality",
        "files": []
      },
      {
        "fullPath": "rules/general/git-workflow",
        "filename": "RULE.md",
        "name": "git-workflow",
        "category": "general",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: Git workflow, branching strategy, and commit conventions. Apply when working with version control.\r\nglobs: \".git/**, .gitignore, CHANGELOG.md\"\r\n---\r\n\r\n# Git Workflow & Conventions\r\n\r\n## Branch Strategy (Gitflow)\r\n\r\n| Branch | Purpose | Rules |\r\n|--------|---------|-------|\r\n| `main` | Production-ready code | Never commit directly |\r\n| `develop` | Latest development changes | Never commit directly |\r\n\r\n### Supporting Branches\r\n\r\n| Type | Branch From | Merge To | Example |\r\n|------|-------------|----------|---------|\r\n| Feature | develop | develop | `feature/123-user-auth` |\r\n| Release | develop | main, develop | `release/v1.2.0` |\r\n| Hotfix | main | main, develop | `hotfix/v1.2.1` |\r\n\r\n## Commit Message Convention\r\n\r\n```\r\n<type>(<scope>): <description>\r\n\r\n[optional body]\r\n\r\n[optional footer(s)]\r\n```\r\n\r\n### Types\r\n\r\n| Type | Description |\r\n|------|-------------|\r\n| `feat` | New feature |\r\n| `fix` | Bug fix |\r\n| `docs` | Documentation changes |\r\n| `style` | Formatting, no code change |\r\n| `refactor` | Code refactoring |\r\n| `perf` | Performance improvement |\r\n| `test` | Adding/updating tests |\r\n| `chore` | Maintenance tasks |\r\n\r\n### Examples\r\n\r\n```bash\r\nfeat(auth): add OAuth2 login support\r\nfix(cart): resolve quantity calculation error\r\nfeat(api)!: change response format for user endpoint\r\n\r\nBREAKING CHANGE: Response now wraps data in 'result' field\r\n```\r\n\r\n## Semantic Versioning\r\n\r\n```\r\nMAJOR.MINOR.PATCH\r\n\r\n1.0.0 → 1.0.1  (PATCH: bug fix)\r\n1.0.1 → 1.1.0  (MINOR: new feature)\r\n1.1.0 → 2.0.0  (MAJOR: breaking changes)\r\n```\r\n\r\n## Pull Request Rules\r\n\r\n1. All changes must go through Pull Requests\r\n2. Minimum 1 approval required\r\n3. CI checks must pass\r\n4. Branch must be up to date before merging\r\n5. Delete branch after merge",
        "files": []
      }
    ],
    "testing": [
      {
        "fullPath": "rules/testing/playwright",
        "filename": "RULE.md",
        "name": "playwright",
        "category": "testing",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: Playwright E2E testing best practices. Apply when writing end-to-end tests with Playwright.\r\nglobs: \"**/*.spec.ts, **/e2e/**/*.ts, playwright.config.ts\"\r\n---\r\n\r\n# Playwright E2E Testing\r\n\r\n## Best Practices\r\n\r\n1. **Descriptive Names** - Use test names that explain behavior\r\n2. **Proper Setup** - Include setup in test.beforeEach blocks\r\n3. **Selector Usage** - Use data-testid over CSS/XPath selectors\r\n4. **Waiting Strategy** - Leverage Playwright's auto-waiting\r\n5. **Mock Dependencies** - Mock external dependencies with page.route\r\n6. **Validation Coverage** - Validate both success and error scenarios\r\n7. **Test Focus** - Limit test files to 3-5 focused tests\r\n\r\n## Test Pattern\r\n\r\n```typescript\r\nimport { test, expect } from '@playwright/test'\r\n\r\ntest.describe('Login Page', () => {\r\n  test.beforeEach(async ({ page }) => {\r\n    // Mock API responses\r\n    await page.route('/api/login', (route) => {\r\n      const body = route.request().postDataJSON()\r\n      if (body.username === 'valid' && body.password === 'valid') {\r\n        route.fulfill({\r\n          status: 200,\r\n          body: JSON.stringify({ token: 'abc123' })\r\n        })\r\n      } else {\r\n        route.fulfill({\r\n          status: 401,\r\n          body: JSON.stringify({ error: 'Invalid credentials' })\r\n        })\r\n      }\r\n    })\r\n    \r\n    await page.goto('/login')\r\n  })\r\n\r\n  test('should login successfully with valid credentials', async ({ page }) => {\r\n    await page.locator('[data-testid=\"username\"]').fill('valid')\r\n    await page.locator('[data-testid=\"password\"]').fill('valid')\r\n    await page.locator('[data-testid=\"submit\"]').click()\r\n    \r\n    await expect(page).toHaveURL('/dashboard')\r\n    await expect(page.locator('[data-testid=\"welcome\"]')).toBeVisible()\r\n  })\r\n\r\n  test('should show error for invalid credentials', async ({ page }) => {\r\n    await page.locator('[data-testid=\"username\"]').fill('invalid')\r\n    await page.locator('[data-testid=\"password\"]').fill('wrong')\r\n    await page.locator('[data-testid=\"submit\"]').click()\r\n    \r\n    await expect(page.locator('[data-testid=\"error\"]')).toHaveText('Invalid credentials')\r\n  })\r\n})\r\n```\r\n\r\n## Selectors\r\n\r\n```typescript\r\n// Preferred: data-testid\r\npage.locator('[data-testid=\"submit-button\"]')\r\n\r\n// Semantic selectors\r\npage.getByRole('button', { name: 'Submit' })\r\npage.getByLabel('Email')\r\npage.getByText('Welcome')\r\n\r\n// Avoid: CSS selectors\r\npage.locator('.btn-primary')  // fragile\r\n```\r\n\r\n## Checklist\r\n\r\n- [ ] Use data-testid selectors\r\n- [ ] Mock API responses for isolation\r\n- [ ] Test both success and error paths\r\n- [ ] Use proper waiting (auto-wait preferred)\r\n- [ ] Keep tests independent",
        "files": []
      },
      {
        "fullPath": "rules/testing/vitest",
        "filename": "RULE.md",
        "name": "vitest",
        "category": "testing",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: Vitest unit testing best practices. Apply when writing unit tests with Vitest.\r\nglobs: \"**/*.test.ts, **/*.spec.ts, vitest.config.ts\"\r\n---\r\n\r\n# Vitest Unit Testing\r\n\r\n## Best Practices\r\n\r\n1. **Critical Functionality First** - Prioritize testing business logic\r\n2. **Mock Dependencies** - Always mock external dependencies\r\n3. **Test Data Scenarios** - Test valid, invalid inputs, and edge cases\r\n4. **Descriptive Naming** - Use clear test names\r\n5. **Test Organization** - Group related tests in describe blocks\r\n6. **Focused Tests** - Limit to 3-5 focused tests per file\r\n\r\n## Test Pattern\r\n\r\n```typescript\r\nimport { describe, it, expect, beforeEach, vi } from 'vitest'\r\n\r\n// Mock dependencies before imports\r\nvi.mock('../api/userService', () => ({\r\n  fetchUser: vi.fn()\r\n}))\r\n\r\nimport { fetchUser } from '../api/userService'\r\nimport { getUserDisplayName } from '../utils/userUtils'\r\n\r\ndescribe('getUserDisplayName', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks()\r\n  })\r\n\r\n  it('should return full name when both names exist', () => {\r\n    // Arrange\r\n    const user = { firstName: 'John', lastName: 'Doe' }\r\n    \r\n    // Act\r\n    const result = getUserDisplayName(user)\r\n    \r\n    // Assert\r\n    expect(result).toBe('John Doe')\r\n  })\r\n\r\n  it('should throw error for null input', () => {\r\n    expect(() => getUserDisplayName(null)).toThrow('User is required')\r\n  })\r\n\r\n  it('should handle undefined properties gracefully', () => {\r\n    const user = {}\r\n    const result = getUserDisplayName(user)\r\n    expect(result).toBe('Unknown User')\r\n  })\r\n})\r\n```\r\n\r\n## Async Testing\r\n\r\n```typescript\r\nit('should fetch user data successfully', async () => {\r\n  const mockUser = { id: '1', name: 'John' }\r\n  ;(fetchUser as any).mockResolvedValue(mockUser)\r\n  \r\n  const result = await getUserData('1')\r\n  \r\n  expect(fetchUser).toHaveBeenCalledWith('1')\r\n  expect(result).toEqual(mockUser)\r\n})\r\n\r\nit('should handle API errors gracefully', async () => {\r\n  ;(fetchUser as any).mockRejectedValue(new Error('Network error'))\r\n  \r\n  await expect(getUserData('1')).rejects.toThrow('Failed to fetch user')\r\n})\r\n```\r\n\r\n## Checklist\r\n\r\n- [ ] Tests follow AAA pattern (Arrange, Act, Assert)\r\n- [ ] Each test has a single assertion focus\r\n- [ ] Dependencies are properly mocked\r\n- [ ] Test names clearly describe behavior\r\n- [ ] Edge cases and error scenarios covered",
        "files": []
      },
      {
        "fullPath": "rules/testing/vue-test-utils",
        "filename": "RULE.md",
        "name": "vue-test-utils",
        "category": "testing",
        "description": "",
        "globs": "",
        "content": "---\r\ndescription: Vue Test Utils component testing best practices. Apply when testing Vue components.\r\nglobs: \"**/*.test.ts, **/*.spec.ts, **/components/**/*.test.ts\"\r\n---\r\n\r\n# Vue Component Testing\r\n\r\n## Setup\r\n\r\n```typescript\r\nimport { mount } from '@vue/test-utils'\r\nimport { createTestingPinia } from '@pinia/testing'\r\nimport { vi } from 'vitest'\r\nimport UserCard from './UserCard.vue'\r\n\r\ndescribe('UserCard', () => {\r\n  const createWrapper = (props = {}, options = {}) => {\r\n    return mount(UserCard, {\r\n      props: {\r\n        user: { id: '1', name: 'John Doe' },\r\n        ...props\r\n      },\r\n      global: {\r\n        plugins: [createTestingPinia({ createSpy: vi.fn })],\r\n        ...options.global\r\n      }\r\n    })\r\n  }\r\n```\r\n\r\n## Testing Patterns\r\n\r\n### Props and Rendering\r\n\r\n```typescript\r\nit('displays user name', () => {\r\n  const wrapper = createWrapper()\r\n  expect(wrapper.text()).toContain('John Doe')\r\n})\r\n\r\nit('shows loading state when isLoading is true', () => {\r\n  const wrapper = createWrapper({ isLoading: true })\r\n  expect(wrapper.find('[data-testid=\"loading\"]').exists()).toBe(true)\r\n})\r\n```\r\n\r\n### Events\r\n\r\n```typescript\r\nit('emits select event when clicked', async () => {\r\n  const wrapper = createWrapper()\r\n  await wrapper.find('[data-testid=\"user-card\"]').trigger('click')\r\n  \r\n  expect(wrapper.emitted('select')).toHaveLength(1)\r\n  expect(wrapper.emitted('select')[0]).toEqual([{ id: '1', name: 'John Doe' }])\r\n})\r\n```\r\n\r\n### Store Interaction\r\n\r\n```typescript\r\nit('calls store action on submit', async () => {\r\n  const wrapper = createWrapper()\r\n  const store = useUserStore()\r\n  \r\n  await wrapper.find('form').trigger('submit')\r\n  \r\n  expect(store.updateUser).toHaveBeenCalled()\r\n})\r\n```\r\n\r\n### Async Operations\r\n\r\n```typescript\r\nit('displays data after async load', async () => {\r\n  const wrapper = createWrapper()\r\n  \r\n  // Wait for async operations\r\n  await flushPromises()\r\n  \r\n  expect(wrapper.find('[data-testid=\"data\"]').exists()).toBe(true)\r\n})\r\n```\r\n\r\n## Checklist\r\n\r\n- [ ] Test component rendering\r\n- [ ] Test props handling\r\n- [ ] Test event emission\r\n- [ ] Test store interactions\r\n- [ ] Test async operations\r\n- [ ] Mock external dependencies",
        "files": []
      }
    ]
  },
  "skills": {
    "abp-framework": [
      {
        "fullPath": "skills/abp-framework/abp-application-service",
        "filename": "SKILL.md",
        "name": "abp-application-service",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-application-service\r\ndescription: Creates ABP Framework application services following QQG conventions. Use this skill when implementing CRUD operations, API endpoints, or coordinating domain operations from the Application layer.\r\n---\r\n\r\n# ABP Application Service Creation\r\n\r\nCreate application services for API endpoints following ABP Framework patterns and QQG conventions.\r\n\r\n## When to Use This Skill\r\n\r\n- Creating CRUD operations for an aggregate root\r\n- Implementing API endpoints\r\n- Coordinating domain services and repositories\r\n- Mapping between DTOs and entities\r\n\r\n## Required Steps\r\n\r\n1. **Create interface** in Application.Contracts: `I{Feature}AppService.cs`\r\n2. **Create DTOs** in Application.Contracts: `{Entity}Dto.cs`, `Create{Entity}Dto.cs`, etc.\r\n3. **Create implementation** in Application: `{Feature}AppService.cs`\r\n4. **Add AutoMapper mappings** in `{ServiceName}ApplicationAutoMapperProfile.cs`\r\n\r\n## File Locations\r\n\r\n```\r\nApplication.Contracts/{Feature}/\r\n├── I{Feature}AppService.cs            # Interface\r\n├── {Entity}Dto.cs                     # Output DTOs\r\n├── Create{Entity}Dto.cs               # Input DTOs\r\n└── Update{Entity}Dto.cs\r\n\r\nApplication/{Feature}/\r\n├── {Feature}AppService.cs             # Implementation\r\n├── I{Entity}CacheService.cs           # Optional cache service\r\n├── {Entity}CacheService.cs\r\n└── Dtos/                              # Feature-specific DTOs (if not in Contracts)\r\n```\r\n\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n## Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Interface | `I{Feature}AppService` | `IProcessingEventAppService` |\r\n| Implementation | `{Feature}AppService` | `ProcessingEventAppService` |\r\n| Basic DTO | `{Entity}Dto` | `ProcessingEventDto` |\r\n| Create DTO | `Create{Entity}Dto` | `CreateProcessingEventDto` |\r\n| Update DTO | `Update{Entity}Dto` | `UpdateProcessingEventDto` |\r\n| List Input | `Get{Entity}ListInput` | `GetProcessingEventListInput` |\r\n\r\n## Template Files\r\n\r\n- `appservice-interface-template.cs` - Interface in Contracts\r\n- `appservice-template.cs` - Implementation\r\n- `dto-templates.cs` - DTO examples\r\n\r\n## Guidelines\r\n\r\n1. **One AppService per aggregate root**\r\n2. **Never return entities** - Always use DTOs\r\n3. **Use custom repositories** - Not generic `IRepository<T>`\r\n4. **Make all public methods virtual** - For extensibility\r\n5. **Make private methods protected virtual** - Allow override\r\n6. **Inherit from ApplicationService** base class\r\n7. **Use ObjectMapper** for entity-DTO mapping\r\n8. **Call repository Update** after entity changes - Not all DBs auto-track\r\n\r\n## Cross-Service Communication\r\n\r\n- **Do NOT** call other AppServices in **same** module - Use domain layer\r\n- **May** call AppServices from **other** modules via contracts only\r\n- **Use** domain services for complex business logic\r\n\r\n## Validation Checklist\r\n\r\n- [ ] Interface defined in Application.Contracts\r\n- [ ] DTOs created with proper validation attributes\r\n- [ ] Implementation inherits from `ApplicationService`\r\n- [ ] Custom repository injected (not generic)\r\n- [ ] AutoMapper profile updated\r\n- [ ] All public methods are `virtual`",
        "files": [
          {
            "name": "appservice-interface-template.cs",
            "content": "// Template: Application Service Interface\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application.Contracts/{Feature}/I{Feature}AppService.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing Volo.Abp.Application.Dtos;\r\nusing Volo.Abp.Application.Services;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Application service for {Entity} operations\r\n/// </summary>\r\npublic interface I{Feature}AppService : IApplicationService\r\n{\r\n    /// <summary>\r\n    /// Gets a single {Entity} by Id\r\n    /// </summary>\r\n    Task<{Entity}Dto> GetAsync(Guid id);\r\n\r\n    /// <summary>\r\n    /// Gets a paged list of {Entity}\r\n    /// </summary>\r\n    Task<PagedResultDto<{Entity}Dto>> GetListAsync(Get{Entity}ListInput input);\r\n\r\n    /// <summary>\r\n    /// Creates a new {Entity}\r\n    /// </summary>\r\n    Task<{Entity}Dto> CreateAsync(Create{Entity}Dto input);\r\n\r\n    /// <summary>\r\n    /// Updates an existing {Entity}\r\n    /// </summary>\r\n    Task<{Entity}Dto> UpdateAsync(Guid id, Update{Entity}Dto input);\r\n\r\n    /// <summary>\r\n    /// Deletes an {Entity}\r\n    /// </summary>\r\n    Task DeleteAsync(Guid id);\r\n}\r\n"
          },
          {
            "name": "appservice-template.cs",
            "content": "// Template: Application Service Implementation\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/{Feature}/{Feature}AppService.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.AspNetCore.Authorization;\r\nusing Volo.Abp.Application.Dtos;\r\nusing Volo.Abp.Application.Services;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Application service for {Entity} operations\r\n/// </summary>\r\n[Authorize]\r\npublic class {Feature}AppService : ApplicationService, I{Feature}AppService\r\n{\r\n    private readonly I{Entity}Repository _repository;\r\n    // Optional: inject domain manager for complex operations\r\n    // private readonly I{Entity}Manager _manager;\r\n\r\n    public {Feature}AppService(\r\n        I{Entity}Repository repository)\r\n    {\r\n        _repository = repository;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets a single {Entity} by Id\r\n    /// </summary>\r\n    public virtual async Task<{Entity}Dto> GetAsync(Guid id)\r\n    {\r\n        var entity = await _repository.GetAsync(id);\r\n        return ObjectMapper.Map<{Entity}, {Entity}Dto>(entity);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets a paged list of {Entity}\r\n    /// </summary>\r\n    public virtual async Task<PagedResultDto<{Entity}Dto>> GetListAsync(Get{Entity}ListInput input)\r\n    {\r\n        var totalCount = await _repository.GetCountAsync(input.Filter);\r\n        var items = await _repository.GetListAsync(\r\n            skipCount: input.SkipCount,\r\n            maxResultCount: input.MaxResultCount,\r\n            sorting: input.Sorting,\r\n            filter: input.Filter\r\n        );\r\n\r\n        return new PagedResultDto<{Entity}Dto>(\r\n            totalCount,\r\n            ObjectMapper.Map<List<{Entity}>, List<{Entity}Dto>>(items)\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// Creates a new {Entity}\r\n    /// </summary>\r\n    public virtual async Task<{Entity}Dto> CreateAsync(Create{Entity}Dto input)\r\n    {\r\n        var entity = new {Entity}(\r\n            id: GuidGenerator.Create(),\r\n            tenantId: CurrentTenant.Id,\r\n            name: input.Name\r\n            // Map other properties\r\n        );\r\n\r\n        await _repository.InsertAsync(entity, autoSave: true);\r\n\r\n        return ObjectMapper.Map<{Entity}, {Entity}Dto>(entity);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Updates an existing {Entity}\r\n    /// </summary>\r\n    public virtual async Task<{Entity}Dto> UpdateAsync(Guid id, Update{Entity}Dto input)\r\n    {\r\n        var entity = await _repository.GetAsync(id);\r\n\r\n        entity.SetName(input.Name);\r\n        // Update other properties\r\n\r\n        await _repository.UpdateAsync(entity, autoSave: true);\r\n\r\n        return ObjectMapper.Map<{Entity}, {Entity}Dto>(entity);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Deletes an {Entity}\r\n    /// </summary>\r\n    public virtual async Task DeleteAsync(Guid id)\r\n    {\r\n        await _repository.DeleteAsync(id);\r\n    }\r\n}\r\n"
          },
          {
            "name": "dto-templates.cs",
            "content": "// Template: DTOs for Application Service\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application.Contracts/{Feature}/Dtos/\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing Volo.Abp.Application.Dtos;\r\n\r\nnamespace QQG.{ServiceName}.{Feature}.Dtos;\r\n\r\n// ============================================\r\n// Output DTO - Basic\r\n// File: {Entity}Dto.cs\r\n// ============================================\r\n[Serializable]\r\npublic class {Entity}Dto : ExtensibleFullAuditedEntityDto<Guid>\r\n{\r\n    public string Name { get; set; } = string.Empty;\r\n    \r\n    // Add other properties\r\n    // Reference other aggregates by Id\r\n    // public Guid CategoryId { get; set; }\r\n}\r\n\r\n// ============================================\r\n// Output DTO - With Details\r\n// File: {Entity}WithDetailsDto.cs\r\n// ============================================\r\n[Serializable]\r\npublic class {Entity}WithDetailsDto : ExtensibleFullAuditedEntityDto<Guid>\r\n{\r\n    public string Name { get; set; } = string.Empty;\r\n    \r\n    // Include related DTOs for detailed view\r\n    // public CategoryDto Category { get; set; }\r\n}\r\n\r\n// ============================================\r\n// Input DTO - Create\r\n// File: Create{Entity}Dto.cs\r\n// ============================================\r\n[Serializable]\r\npublic class Create{Entity}Dto\r\n{\r\n    [Required]\r\n    [StringLength(256)]\r\n    public string Name { get; set; } = string.Empty;\r\n    \r\n    // Add other required properties with validation\r\n}\r\n\r\n// ============================================\r\n// Input DTO - Update\r\n// File: Update{Entity}Dto.cs\r\n// ============================================\r\n[Serializable]\r\npublic class Update{Entity}Dto\r\n{\r\n    [Required]\r\n    [StringLength(256)]\r\n    public string Name { get; set; } = string.Empty;\r\n    \r\n    // Add updatable properties\r\n}\r\n\r\n// ============================================\r\n// Input DTO - List Query\r\n// File: Get{Entity}ListInput.cs\r\n// ============================================\r\n[Serializable]\r\npublic class Get{Entity}ListInput : PagedAndSortedResultRequestDto\r\n{\r\n    public string? Filter { get; set; }\r\n    \r\n    // Add other filter properties\r\n    // public Guid? CategoryId { get; set; }\r\n    // public DateTime? StartDate { get; set; }\r\n}\r\n"
          }
        ]
      },
      {
        "fullPath": "skills/abp-framework/abp-background-worker",
        "filename": "SKILL.md",
        "name": "abp-background-worker",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-background-worker\r\ndescription: Creates ABP Framework background workers and background jobs following QQG conventions. Use this skill when implementing periodic tasks, queued jobs, or async processing.\r\n---\r\n\r\n# ABP Background Worker & Job Creation\r\n\r\nCreate background workers (periodic tasks) and background jobs (queued one-time tasks).\r\n\r\n## Worker vs Job Decision\r\n\r\n| Type | Use Case | Execution |\r\n|------|----------|-----------|\r\n| **Background Worker** | Polling, cleanup, recovery | Runs periodically on timer |\r\n| **Background Job** | Emails, logging, async tasks | Queued, executed once |\r\n\r\n## Background Workers\r\n\r\nPeriodic tasks that run in the background on a timer.\r\n\r\n### When to Use\r\n- Periodic cleanup tasks\r\n- Scheduled data sync\r\n- Health checks\r\n- Cache refresh\r\n\r\n### File Location\r\n```\r\nApplication/\r\n├── BackgroundWorkers/                 # Root-level folder for ALL workers\r\n│   ├── {Name}Worker.cs\r\n│   └── {Name}Configuration.cs         # Optional worker config\r\n```\r\n\r\n> **Note**: Workers go in a root-level `BackgroundWorkers/` folder, NOT in feature folders\r\n\r\n### Template Files\r\n- `worker-template.cs` - Worker implementation\r\n- `worker-configuration-template.cs` - Configuration class\r\n\r\n### Registration\r\nRegister in HttpApi.Host module's `OnApplicationInitializationAsync`:\r\n```csharp\r\nawait context.AddBackgroundWorkerAsync<{Name}Worker>();\r\n```\r\n\r\n## Background Jobs\r\n\r\nOne-time tasks that are queued and executed asynchronously.\r\n\r\n### When to Use Jobs\r\n- Sending emails/notifications\r\n- Recording audit logs asynchronously\r\n- Tasks that can be retried on failure\r\n- Long-running operations\r\n\r\n### File Location\r\n```\r\nApplication/\r\n├── BackgroundJobs/                    # Root-level folder for ALL jobs\r\n│   ├── {Name}Job.cs\r\n│   └── {Name}Args.cs\r\n```\r\n\r\n> **Note**: Jobs go in a root-level `BackgroundJobs/` folder, NOT in feature folders\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n### Template Files\r\n- `job-template.cs` - Job implementation with Args class\r\n\r\n### Queuing a Job\r\n```csharp\r\nawait _backgroundJobManager.EnqueueAsync(new {Name}Args { ... });\r\n```\r\n\r\n## ABP Official Guidelines\r\n\r\n### Background Workers\r\n1. **Resolve dependencies from `workerContext.ServiceProvider`** - NOT constructor injection\r\n2. **Worker uses `IServiceScope`** - Disposed when work finishes\r\n3. **Exceptions are auto-caught and logged** by `AsyncPeriodicBackgroundWorkerBase`\r\n4. **Register in `OnApplicationInitializationAsync`** - Use `context.AddBackgroundWorkerAsync<T>()`\r\n5. **Consider clustered deployment** - Use distributed lock if needed\r\n\r\n### Background Jobs\r\n1. **Use `AsyncBackgroundJob<TArgs>`** - For async operations\r\n2. **Jobs auto-retry on exception** - Hide exception only if no retry needed\r\n3. **Use `ICancellationTokenProvider`** - For cancellable jobs\r\n4. **Use `[BackgroundJobName]` attribute** - For custom job naming\r\n5. **Include TenantId in args** - For multi-tenant operations\r\n\r\n## Validation Checklist\r\n\r\n### Worker\r\n- [ ] Inherits from `AsyncPeriodicBackgroundWorkerBase`\r\n- [ ] Has `[UnitOfWork]` attribute\r\n- [ ] Resolves scoped services from `workerContext.ServiceProvider`\r\n- [ ] Registered in HttpApi.Host module\r\n\r\n### Job\r\n- [ ] Inherits from `AsyncBackgroundJob<{Name}Args>` (for async operations)\r\n- [ ] Implements `ITransientDependency`\r\n- [ ] Args class has `[Serializable]` attribute\r\n- [ ] Args includes `TenantId` for multi-tenancy\r\n- [ ] Uses `ICancellationTokenProvider` if cancellable",
        "files": [
          {
            "name": "job-template.cs",
            "content": "// Template: Background Job with Args\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/BackgroundJobs/\r\n// Files: {Name}Args.cs, {Name}Job.cs\r\n// Replace: {ServiceName}, {Name}, {Entity}\r\n\r\nusing System;\r\nusing Microsoft.Extensions.Logging;\r\nusing Volo.Abp.BackgroundJobs;\r\nusing Volo.Abp.DependencyInjection;\r\nusing Volo.Abp.MultiTenancy;\r\nusing Volo.Abp.Uow;\r\n\r\nnamespace QQG.{ServiceName}.BackgroundJobs;\r\n\r\n// ============================================\r\n// Job Arguments\r\n// File: {Name}Args.cs\r\n// ============================================\r\n\r\n/// <summary>\r\n/// Arguments for {Name} background job\r\n/// </summary>\r\n[Serializable]\r\npublic class {Name}Args\r\n{\r\n    /// <summary>\r\n    /// Tenant Id for multi-tenant operations\r\n    /// </summary>\r\n    public Guid? TenantId { get; set; }\r\n\r\n    /// <summary>\r\n    /// Entity Id to process\r\n    /// </summary>\r\n    public Guid EntityId { get; set; }\r\n\r\n    // Add other properties as needed\r\n    // public string AdditionalData { get; set; }\r\n}\r\n\r\n// ============================================\r\n// Job Implementation\r\n// File: {Name}Job.cs\r\n// ============================================\r\n\r\n/// <summary>\r\n/// Background job for {description}\r\n/// NOTE: Use AsyncBackgroundJob for async operations per ABP best practices\r\n/// </summary>\r\npublic class {Name}Job : AsyncBackgroundJob<{Name}Args>, ITransientDependency\r\n{\r\n    private readonly ILogger<{Name}Job> _logger;\r\n    private readonly I{Entity}Repository _repository;\r\n    private readonly ICurrentTenant _currentTenant;\r\n\r\n    public {Name}Job(\r\n        ILogger<{Name}Job> logger,\r\n        I{Entity}Repository repository,\r\n        ICurrentTenant currentTenant)\r\n    {\r\n        _logger = logger;\r\n        _repository = repository;\r\n        _currentTenant = currentTenant;\r\n    }\r\n\r\n    [UnitOfWork]\r\n    public override void Execute({Name}Args args)\r\n    {\r\n        _logger.LogInformation(\"Executing {JobName} for entity {EntityId}\",\r\n            nameof({Name}Job), args.EntityId);\r\n\r\n        try\r\n        {\r\n            // Switch to correct tenant context\r\n            using (_currentTenant.Change(args.TenantId))\r\n            {\r\n                // Get and process the entity\r\n                var entity = _repository.GetAsync(args.EntityId).GetAwaiter().GetResult();\r\n\r\n                // Do the work...\r\n                // ProcessEntity(entity);\r\n\r\n                _logger.LogInformation(\"Completed {JobName} for entity {EntityId}\",\r\n                    nameof({Name}Job), args.EntityId);\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, \"Error in {JobName} for entity {EntityId}\",\r\n                nameof({Name}Job), args.EntityId);\r\n            throw; // Re-throw to allow retry\r\n        }\r\n    }\r\n}\r\n\r\n// ============================================\r\n// How to Queue the Job\r\n// ============================================\r\n/*\r\npublic class SomeAppService : ApplicationService\r\n{\r\n    private readonly IBackgroundJobManager _backgroundJobManager;\r\n\r\n    public SomeAppService(IBackgroundJobManager backgroundJobManager)\r\n    {\r\n        _backgroundJobManager = backgroundJobManager;\r\n    }\r\n\r\n    public async Task TriggerJobAsync(Guid entityId)\r\n    {\r\n        await _backgroundJobManager.EnqueueAsync(\r\n            new {Name}Args\r\n            {\r\n                TenantId = CurrentTenant.Id,\r\n                EntityId = entityId\r\n            }\r\n        );\r\n    }\r\n}\r\n*/\r\n"
          },
          {
            "name": "worker-template.cs",
            "content": "// Template: Background Worker\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/BackgroundWorkers/{Name}Worker.cs\r\n// Replace: {ServiceName}, {Name}, {Entity}\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing Volo.Abp.BackgroundWorkers;\r\nusing Volo.Abp.Threading;\r\nusing Volo.Abp.Uow;\r\n\r\nnamespace QQG.{ServiceName}.BackgroundWorkers;\r\n\r\n/// <summary>\r\n/// Background worker for {description}\r\n/// Runs periodically to process pending work\r\n/// </summary>\r\n[UnitOfWork]\r\npublic class {Name}Worker : AsyncPeriodicBackgroundWorkerBase\r\n{\r\n    private readonly ILogger<{Name}Worker> _logger;\r\n\r\n    public {Name}Worker(\r\n        AbpAsyncTimer timer,\r\n        IServiceScopeFactory serviceScopeFactory,\r\n        ILogger<{Name}Worker> logger) : base(timer, serviceScopeFactory)\r\n    {\r\n        _logger = logger;\r\n        \r\n        // Configure timer period (milliseconds)\r\n        Timer.Period = 60000; // 1 minute - adjust as needed\r\n    }\r\n\r\n    protected override async Task DoWorkAsync(PeriodicBackgroundWorkerContext workerContext)\r\n    {\r\n        _logger.LogDebug(\"{WorkerName} starting work cycle\", nameof({Name}Worker));\r\n\r\n        try\r\n        {\r\n            // Resolve scoped services from context (NOT constructor injection)\r\n            var repository = workerContext.ServiceProvider\r\n                .GetRequiredService<I{Entity}Repository>();\r\n\r\n            // Get pending items to process\r\n            var pendingItems = await repository.GetListAsync(\r\n                skipCount: 0,\r\n                maxResultCount: 100,\r\n                filter: \"pending\"\r\n            );\r\n\r\n            foreach (var item in pendingItems)\r\n            {\r\n                try\r\n                {\r\n                    // Process each item\r\n                    // await ProcessItemAsync(item);\r\n                    \r\n                    _logger.LogDebug(\"Processed item {ItemId}\", item.Id);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    _logger.LogError(ex, \"Error processing item {ItemId}\", item.Id);\r\n                    // Continue with next item, don't break the loop\r\n                }\r\n            }\r\n\r\n            _logger.LogDebug(\"{WorkerName} completed. Processed {Count} items\",\r\n                nameof({Name}Worker), pendingItems.Count);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, \"{WorkerName} encountered an error\", nameof({Name}Worker));\r\n        }\r\n    }\r\n}\r\n"
          }
        ]
      },
      {
        "fullPath": "skills/abp-framework/abp-cache-service",
        "filename": "SKILL.md",
        "name": "abp-cache-service",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-cache-service\r\ndescription: Creates ABP Framework cache services following QQG conventions. Use this skill when implementing distributed caching for entities or data that needs to be cached for performance.\r\n---\r\n\r\n# ABP Cache Service Creation\r\n\r\nCreate cache services for efficient data access using ABP's distributed caching system.\r\n\r\n## When to Use Cache Services\r\n\r\n- Frequently accessed data that rarely changes\r\n- Expensive database queries or calculations\r\n- Data shared across requests/users\r\n- Reducing database load\r\n\r\n## Required Components\r\n\r\n1. **Cache Item Class** - DTO-like class for cached data\r\n2. **Cache Service Interface** - `I{Entity}CacheService`\r\n3. **Cache Service Implementation** - Uses `IDistributedCache<T>`\r\n4. **Event Handler** - Invalidates cache on entity changes\r\n\r\n## File Locations\r\n\r\n```\r\nApplication/\r\n├── {Feature}/\r\n│   ├── I{Entity}CacheService.cs\r\n│   ├── {Entity}CacheService.cs\r\n│   └── {Entity}CacheItem.cs (if separate from DTO)\r\n```\r\n\r\n## Template Files\r\n\r\n- `cache-service-interface-template.cs` - Interface definition\r\n- `cache-service-template.cs` - Implementation with ABP patterns\r\n- `cache-item-template.cs` - Cache item class\r\n\r\n## ABP Cache Features\r\n\r\n### Key Features\r\n- **Auto serialization/deserialization** - JSON by default\r\n- **Auto tenant isolation** - TenantId added to cache key\r\n- **Error tolerance** - Errors hidden by default, falls back to source\r\n- **Batch operations** - `GetManyAsync`, `SetManyAsync`\r\n- **Unit of Work integration** - `considerUow` parameter\r\n\r\n### Cache Key Best Practices\r\n- Use `[CacheName(\"MyCache\")]` attribute for custom cache names\r\n- Use `[IgnoreMultiTenancy]` if cache shared across tenants\r\n- Configure `KeyPrefix` for multi-app environments\r\n\r\n### Important Methods\r\n```csharp\r\n// Get or add with factory\r\nawait _cache.GetOrAddAsync(key, factory, options);\r\n\r\n// Batch operations\r\nawait _cache.GetManyAsync(keys);\r\nawait _cache.SetManyAsync(items);\r\n\r\n// Remove\r\nawait _cache.RemoveAsync(key);\r\n```\r\n\r\n## Cache Invalidation Pattern\r\n\r\nAlways invalidate cache when entity changes:\r\n1. Create local event handler for entity events\r\n2. Call `InvalidateCacheAsync()` on create/update/delete\r\n\r\n## ABP Official Guidelines\r\n\r\n1. **Use `IDistributedCache<T>`** - NOT standard `IDistributedCache`\r\n2. **Use `GetOrAddAsync`** - Factory pattern for cache miss\r\n3. **Set appropriate expiration** - `AbsoluteExpiration` or `SlidingExpiration`\r\n4. **Consider `considerUow: true`** - For transactional consistency\r\n5. **Handle batch operations** - Use `GetManyAsync`/`SetManyAsync`\r\n\r\n---\r\n\r\n## Entity Cache (Built-in Auto-Invalidation)\r\n\r\nABP provides a simpler `IEntityCache<T, TKey>` for caching entities with **automatic invalidation** on update/delete.\r\n\r\n### Registration\r\n```csharp\r\n// In module ConfigureServices\r\n// Option 1: Cache entity directly\r\ncontext.Services.AddEntityCache<Product, Guid>();\r\n\r\n// Option 2: Cache as DTO (requires AutoMapper config)\r\ncontext.Services.AddEntityCache<Product, ProductDto, Guid>();\r\n\r\n// With custom expiration\r\ncontext.Services.AddEntityCache<Product, ProductDto, Guid>(\r\n    new DistributedCacheEntryOptions \r\n    { \r\n        SlidingExpiration = TimeSpan.FromMinutes(30) \r\n    }\r\n);\r\n```\r\n\r\n### Usage\r\n```csharp\r\npublic class ProductAppService : ApplicationService\r\n{\r\n    private readonly IEntityCache<ProductDto, Guid> _productCache;\r\n\r\n    public ProductAppService(IEntityCache<ProductDto, Guid> productCache)\r\n    {\r\n        _productCache = productCache;\r\n    }\r\n\r\n    public async Task<ProductDto> GetAsync(Guid id)\r\n    {\r\n        // Auto-fetches from DB on first call, then from cache\r\n        // Auto-invalidates when entity is updated/deleted\r\n        return await _productCache.GetAsync(id);\r\n    }\r\n}\r\n```\r\n\r\n### Important Notes\r\n- **Read-only** - Use repository for updates, not entity cache\r\n- **Auto-invalidation** - No manual invalidation needed\r\n- **Default 2 min expiration** - Configure via `DistributedCacheEntryOptions`\r\n- Requires entity to be JSON-serializable (or use DTO)\r\n\r\n### Limitations & When NOT to Use Entity Cache\r\n\r\n| Limitation | Description | Solution |\r\n|------------|-------------|----------|\r\n| **Single entity only** | Only caches by primary key (GetAsync(id)) | Use custom cache for lists |\r\n| **No child entity tracking** | Child entity changes don't invalidate parent | Use custom cache + event handlers |\r\n| **No includeDetails** | Repository fetch may not include children | Custom cache with explicit includes |\r\n| **No collection caching** | Cannot cache `GetListAsync()` results | Use `IDistributedCache<List<T>>` |\r\n| **No composite keys** | Only supports single key lookups | Use custom cache with string keys |\r\n| **No query caching** | Cannot cache filtered/sorted results | Use custom cache service |\r\n\r\n### ⚠️ Critical: Child Entities NOT Included by Default\r\n\r\nWhen `IEntityCache` fetches an entity from the repository, it uses the default repository behavior which **may not include child entities** (navigation properties).\r\n\r\n```csharp\r\n// IEntityCache internally calls repository like this:\r\nvar entity = await _repository.GetAsync(id);  // No includeDetails!\r\n\r\n// Child collections will be EMPTY in cache!\r\n// order.OrderLines = [] (empty!)\r\n```\r\n\r\n**Solution**: For entities with children, use **Custom Cache Service** with explicit includes:\r\n\r\n```csharp\r\npublic class OrderCacheService : IOrderCacheService, ITransientDependency\r\n{\r\n    private readonly IOrderRepository _repository;\r\n    private readonly IDistributedCache<OrderDto, Guid> _cache;\r\n\r\n    public async Task<OrderDto> GetWithDetailsAsync(Guid id)\r\n    {\r\n        return await _cache.GetOrAddAsync(\r\n            id,\r\n            async () =>\r\n            {\r\n                // Explicitly include children!\r\n                var order = await _repository.GetAsync(id, includeDetails: true);\r\n                // OR use custom repository method\r\n                // var order = await _repository.GetWithLinesAsync(id);\r\n                \r\n                return ObjectMapper.Map<Order, OrderDto>(order);\r\n            }\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n### When to Use Entity Cache vs Custom Cache\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    Which Cache Pattern?                          │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│                                                                  │\r\n│  Need to cache single entity by ID?                             │\r\n│    ├── YES, entity has NO child collections → IEntityCache ✓   │\r\n│    ├── YES, but has child entities → Custom Cache + Events     │\r\n│    └── NO → Custom Cache Service                                │\r\n│                                                                  │\r\n│  Need to cache lists/collections?                               │\r\n│    └── Always use Custom Cache Service                          │\r\n│                                                                  │\r\n│  Need to cache grouped/filtered data?                           │\r\n│    └── Always use Custom Cache Service                          │\r\n│                                                                  │\r\n│  Child entity changes should invalidate cache?                  │\r\n│    └── Custom Cache + Handle child entity events                │\r\n│                                                                  │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Example: Caching Entity with Children (Custom Cache Required)\r\n\r\n```csharp\r\n// Order has OrderLines - IEntityCache won't work properly\r\n// Because OrderLine changes won't invalidate Order cache\r\n\r\npublic class OrderCacheService : IOrderCacheService, ITransientDependency\r\n{\r\n    private readonly IDistributedCache<OrderWithLinesDto, Guid> _cache;\r\n    \r\n    // Must handle BOTH Order and OrderLine events\r\n}\r\n\r\n// Event handler for cache invalidation\r\npublic class OrderCacheInvalidationHandler :\r\n    ILocalEventHandler<EntityChangedEventData<Order>>,\r\n    ILocalEventHandler<EntityChangedEventData<OrderLine>>,  // Child!\r\n    ITransientDependency\r\n{\r\n    private readonly IOrderCacheService _cacheService;\r\n    \r\n    public async Task HandleEventAsync(EntityChangedEventData<Order> e)\r\n        => await _cacheService.InvalidateCacheAsync(e.Entity.Id);\r\n    \r\n    public async Task HandleEventAsync(EntityChangedEventData<OrderLine> e)\r\n        => await _cacheService.InvalidateCacheAsync(e.Entity.OrderId);  // Parent ID!\r\n}\r\n```\r\n\r\n### Example: Caching Groups/Lists (Custom Cache Required)\r\n\r\n```csharp\r\n// IEntityCache cannot cache \"all active products\" or \"products by category\"\r\n// Use custom cache with meaningful keys\r\n\r\npublic class ProductCacheService : IProductCacheService, ITransientDependency\r\n{\r\n    private readonly IDistributedCache<List<ProductDto>> _listCache;\r\n    \r\n    private string GetCategoryKey(Guid categoryId) \r\n        => $\"Products:Category:{categoryId}\";\r\n    \r\n    private const string ActiveProductsKey = \"Products:Active:All\";\r\n    \r\n    public async Task<List<ProductDto>> GetByCategoryAsync(Guid categoryId)\r\n    {\r\n        return await _listCache.GetOrAddAsync(\r\n            GetCategoryKey(categoryId),\r\n            async () => await LoadFromDatabase(categoryId),\r\n            () => new DistributedCacheEntryOptions { ... }\r\n        );\r\n    }\r\n    \r\n    // Must invalidate ALL related cache keys on product change\r\n    public async Task InvalidateCacheAsync(Product product)\r\n    {\r\n        await _listCache.RemoveAsync(GetCategoryKey(product.CategoryId));\r\n        await _listCache.RemoveAsync(ActiveProductsKey);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Validation Checklist\r\n\r\n### Custom Cache Service\r\n- [ ] Cache item class defined (or reusing DTO)\r\n- [ ] Interface with `GetAsync` and `InvalidateCacheAsync` methods\r\n- [ ] Implementation uses `IDistributedCache<T>`\r\n- [ ] Uses `GetOrAddAsync` for cache-aside pattern\r\n- [ ] Expiration options configured\r\n- [ ] Event handler created for cache invalidation\r\n- [ ] Implements `ITransientDependency`\r\n\r\n### Entity Cache (Simpler)\r\n- [ ] `AddEntityCache<T, TKey>()` registered in module\r\n- [ ] AutoMapper configured if using DTO\r\n- [ ] Entity is JSON-serializable\r\n- [ ] Use repository for writes (cache is read-only)",
        "files": [
          {
            "name": "cache-item-template.cs",
            "content": "// Template: Cache Item Class\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/{Feature}/{Entity}CacheItem.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n// NOTE: You can also reuse existing DTOs instead of creating separate cache items\r\n\r\nusing System;\r\nusing Volo.Abp.Caching;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n// ============================================\r\n// Option 1: Basic Cache Item (reuse DTO pattern)\r\n// ============================================\r\n\r\n/// <summary>\r\n/// Cache item for {Entity} data\r\n/// Uses CacheName attribute to customize cache key prefix\r\n/// </summary>\r\n[CacheName(\"{Entity}\")]\r\n[Serializable]\r\npublic class {Entity}CacheItem\r\n{\r\n    public Guid Id { get; set; }\r\n    \r\n    public string Name { get; set; } = string.Empty;\r\n    \r\n    // Add other frequently accessed properties\r\n    // Keep it lightweight - only include what's needed for cache\r\n}\r\n\r\n// ============================================\r\n// Option 2: Shared Cache Item (multi-tenant disabled)\r\n// ============================================\r\n\r\n/// <summary>\r\n/// Cache item shared across all tenants\r\n/// Use IgnoreMultiTenancy when data is the same for all tenants\r\n/// </summary>\r\n[CacheName(\"Shared{Entity}\")]\r\n[IgnoreMultiTenancy]\r\n[Serializable]\r\npublic class Shared{Entity}CacheItem\r\n{\r\n    public Guid Id { get; set; }\r\n    \r\n    public string Name { get; set; } = string.Empty;\r\n}\r\n\r\n// ============================================\r\n// Usage Notes\r\n// ============================================\r\n/*\r\nABP Cache Key Generation:\r\n- Default format: {CacheName}:{TenantId}:{Key}\r\n- With [IgnoreMultiTenancy]: {CacheName}:{Key}\r\n- CacheName defaults to full class name without \"CacheItem\" suffix\r\n\r\nExample:\r\n- MyProject.BookCacheItem with key \"123\" and tenant \"abc\"\r\n- Cache key: \"MyProject.Book:abc:123\"\r\n\r\nWith [CacheName(\"Books\")]:\r\n- Cache key: \"Books:abc:123\"\r\n\r\nConfiguration:\r\nConfigure<AbpDistributedCacheOptions>(options =>\r\n{\r\n    options.KeyPrefix = \"MyApp:\";\r\n    options.GlobalCacheEntryOptions = new DistributedCacheEntryOptions\r\n    {\r\n        SlidingExpiration = TimeSpan.FromMinutes(20)\r\n    };\r\n});\r\n*/\r\n"
          },
          {
            "name": "cache-service-interface-template.cs",
            "content": "// Template: Cache Service Interface\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/{Feature}/I{Entity}CacheService.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Cache service interface for {Entity}\r\n/// </summary>\r\npublic interface I{Entity}CacheService\r\n{\r\n    /// <summary>\r\n    /// Gets all {Entity} items from cache or database\r\n    /// </summary>\r\n    Task<List<{Entity}Dto>> GetAllAsync();\r\n\r\n    /// <summary>\r\n    /// Gets a single {Entity} by Id from cache or database\r\n    /// </summary>\r\n    Task<{Entity}Dto?> GetByIdAsync(Guid id);\r\n\r\n    /// <summary>\r\n    /// Invalidates all cache entries for {Entity}\r\n    /// </summary>\r\n    Task InvalidateCacheAsync();\r\n\r\n    /// <summary>\r\n    /// Invalidates cache entry for a specific {Entity}\r\n    /// </summary>\r\n    Task InvalidateCacheAsync(Guid id);\r\n}\r\n"
          },
          {
            "name": "cache-service-template.cs",
            "content": "// Template: Cache Service Implementation\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/{Feature}/{Entity}CacheService.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.Extensions.Caching.Distributed;\r\nusing Microsoft.Extensions.Logging;\r\nusing Volo.Abp.Caching;\r\nusing Volo.Abp.DependencyInjection;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Cache service for {Entity}\r\n/// Uses ABP's IDistributedCache for distributed caching\r\n/// </summary>\r\npublic class {Entity}CacheService : I{Entity}CacheService, ITransientDependency\r\n{\r\n    // Cache for list of all entities\r\n    private readonly IDistributedCache<List<{Entity}Dto>> _listCache;\r\n    \r\n    // Cache for individual entities (use TCacheKey for typed keys)\r\n    private readonly IDistributedCache<{Entity}Dto, Guid> _itemCache;\r\n    \r\n    private readonly I{Entity}Repository _repository;\r\n    private readonly ILogger<{Entity}CacheService> _logger;\r\n    \r\n    // Cache key for the full list\r\n    private const string AllItemsCacheKey = \"{Entity}:All\";\r\n\r\n    public {Entity}CacheService(\r\n        IDistributedCache<List<{Entity}Dto>> listCache,\r\n        IDistributedCache<{Entity}Dto, Guid> itemCache,\r\n        I{Entity}Repository repository,\r\n        ILogger<{Entity}CacheService> logger)\r\n    {\r\n        _listCache = listCache;\r\n        _itemCache = itemCache;\r\n        _repository = repository;\r\n        _logger = logger;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets all {Entity} items from cache, or loads from database if not cached\r\n    /// Uses GetOrAddAsync for cache-aside pattern per ABP best practices\r\n    /// </summary>\r\n    public virtual async Task<List<{Entity}Dto>> GetAllAsync()\r\n    {\r\n        return await _listCache.GetOrAddAsync(\r\n            AllItemsCacheKey,\r\n            async () =>\r\n            {\r\n                _logger.LogDebug(\"Cache miss for {CacheKey}, loading from database\", AllItemsCacheKey);\r\n                \r\n                var entities = await _repository.GetListAsync(\r\n                    skipCount: 0,\r\n                    maxResultCount: int.MaxValue\r\n                );\r\n                \r\n                return entities.Select(e => new {Entity}Dto\r\n                {\r\n                    Id = e.Id,\r\n                    Name = e.Name\r\n                    // Map other properties\r\n                }).ToList();\r\n            },\r\n            () => new DistributedCacheEntryOptions\r\n            {\r\n                // Use sliding expiration for frequently accessed data\r\n                SlidingExpiration = TimeSpan.FromMinutes(30),\r\n                // Or absolute expiration for time-sensitive data\r\n                // AbsoluteExpiration = DateTimeOffset.Now.AddHours(1)\r\n            }\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets a single {Entity} by Id from cache or database\r\n    /// </summary>\r\n    public virtual async Task<{Entity}Dto?> GetByIdAsync(Guid id)\r\n    {\r\n        return await _itemCache.GetOrAddAsync(\r\n            id, // ABP auto-converts Guid to cache key\r\n            async () =>\r\n            {\r\n                _logger.LogDebug(\"Cache miss for {Entity} {Id}, loading from database\", \r\n                    nameof({Entity}), id);\r\n                \r\n                var entity = await _repository.FindAsync(id);\r\n                if (entity == null) return null;\r\n                \r\n                return new {Entity}Dto\r\n                {\r\n                    Id = entity.Id,\r\n                    Name = entity.Name\r\n                    // Map other properties\r\n                };\r\n            },\r\n            () => new DistributedCacheEntryOptions\r\n            {\r\n                SlidingExpiration = TimeSpan.FromMinutes(30)\r\n            }\r\n        );\r\n    }\r\n\r\n    /// <summary>\r\n    /// Invalidates all cache entries for {Entity}\r\n    /// Call this when entities are created/updated/deleted\r\n    /// </summary>\r\n    public virtual async Task InvalidateCacheAsync()\r\n    {\r\n        _logger.LogDebug(\"Invalidating all {Entity} cache\", nameof({Entity}));\r\n        await _listCache.RemoveAsync(AllItemsCacheKey);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Invalidates cache entry for a specific {Entity}\r\n    /// </summary>\r\n    public virtual async Task InvalidateCacheAsync(Guid id)\r\n    {\r\n        _logger.LogDebug(\"Invalidating cache for {Entity} {Id}\", nameof({Entity}), id);\r\n        \r\n        // Remove both the individual item and the list cache\r\n        await _itemCache.RemoveAsync(id);\r\n        await _listCache.RemoveAsync(AllItemsCacheKey);\r\n    }\r\n}\r\n"
          }
        ]
      },
      {
        "fullPath": "skills/abp-framework/abp-domain-service",
        "filename": "SKILL.md",
        "name": "abp-domain-service",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-domain-service\r\ndescription: Creates ABP Framework domain services and managers following QQG conventions. Use this skill when implementing business logic that spans multiple entities or requires complex domain operations.\r\n---\r\n\r\n# ABP Domain Service Creation\r\n\r\nCreate domain services (managers) for complex business logic following ABP Framework patterns.\r\n\r\n## When to Use Domain Services\r\n\r\nUse a domain service when:\r\n- Business logic spans **multiple aggregate roots**\r\n- Logic requires **external service calls** (other microservices, APIs)\r\n- **Complex calculations** that don't belong to a single entity\r\n- Operations that need **repository access** beyond a single aggregate\r\n\r\n## Do NOT Use Domain Services When\r\n\r\n- Logic belongs to a single entity → Put it in the entity itself\r\n- Simple CRUD operations → Use application services directly\r\n- Cross-cutting concerns → Use interceptors or middleware\r\n\r\n## Required Steps\r\n\r\n1. **Create implementation** in Domain project: `{Name}Manager.cs`\r\n2. **Inherit from `DomainService`** base class\r\n3. **Inject dependencies** (repositories, other domain services)\r\n4. *(Optional)* Create interface only if needed for testing/mocking\r\n\r\n> **Note**: ABP recommends NOT creating interfaces for domain services unless needed for testing.\r\n\r\n## File Location\r\n\r\n```\r\nservices/{ServiceName}/src/QQG.{ServiceName}.Domain/{Feature}/\r\n├── I{Name}Manager.cs\r\n└── {Name}Manager.cs\r\n```\r\n\r\n## Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Interface | `I{Name}Manager` | `IProcessingEventManager` |\r\n| Implementation | `{Name}Manager` | `ProcessingEventManager` |\r\n\r\n## Template Files\r\n\r\n- `domain-service-interface-template.cs` - Interface definition\r\n- `domain-service-template.cs` - Implementation\r\n\r\n## Guidelines\r\n\r\n1. **Keep domain services focused** - One responsibility per service\r\n2. **Do NOT define GET methods** - Use repository directly in AppService for reads\r\n3. **Define methods that mutate data** - Change entity state only\r\n4. **Use self-explanatory names** - Like `AssignToAsync`, not `UpdateAsync`\r\n5. **Accept valid domain objects** - Pass entities, not DTOs\r\n6. **Use Check class** for validation - `Check.NotNull()`, `Check.NotNullOrWhiteSpace()`\r\n7. **Throw BusinessException** - With domain error codes for localization\r\n8. **Make methods virtual** for extensibility\r\n9. **Do NOT return DTOs** - Return domain objects only\r\n\r\n## Validation Checklist\r\n\r\n- [ ] Interface defined with clear method signatures\r\n- [ ] Implementation inherits from `DomainService`\r\n- [ ] Implements `ITransientDependency`\r\n- [ ] All methods are `virtual`\r\n- [ ] Proper exception handling\r\n- [ ] Logging added for key operations",
        "files": [
          {
            "name": "domain-service-interface-template.cs",
            "content": "// Template: Domain Service Interface\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Domain/{Feature}/I{Name}Manager.cs\r\n// Replace: {ServiceName}, {Feature}, {Name}, {Entity}\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Domain service for managing {Entity} operations\r\n/// </summary>\r\npublic interface I{Name}Manager\r\n{\r\n    /// <summary>\r\n    /// Creates a new {Entity} with validation\r\n    /// </summary>\r\n    Task<{Entity}> CreateAsync(\r\n        Guid? tenantId,\r\n        string name,\r\n        // Add other parameters\r\n        );\r\n\r\n    /// <summary>\r\n    /// Updates an existing {Entity}\r\n    /// </summary>\r\n    Task<{Entity}> UpdateAsync(\r\n        {Entity} entity,\r\n        string name\r\n        // Add other parameters\r\n        );\r\n\r\n    /// <summary>\r\n    /// Validates business rules before operation\r\n    /// </summary>\r\n    Task ValidateAsync({Entity} entity);\r\n}\r\n"
          },
          {
            "name": "domain-service-template.cs",
            "content": "// Template: Domain Service Implementation\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Domain/{Feature}/{Name}Manager.cs\r\n// Replace: {ServiceName}, {Feature}, {Name}, {Entity}\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.Extensions.Logging;\r\nusing Volo.Abp;\r\nusing Volo.Abp.Domain.Services;\r\nusing Volo.Abp.Guids;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Domain service for managing {Entity} operations\r\n/// </summary>\r\npublic class {Name}Manager : DomainService, I{Name}Manager\r\n{\r\n    private readonly I{Entity}Repository _repository;\r\n    private readonly IGuidGenerator _guidGenerator;\r\n    private readonly ILogger<{Name}Manager> _logger;\r\n\r\n    public {Name}Manager(\r\n        I{Entity}Repository repository,\r\n        IGuidGenerator guidGenerator,\r\n        ILogger<{Name}Manager> logger)\r\n    {\r\n        _repository = repository;\r\n        _guidGenerator = guidGenerator;\r\n        _logger = logger;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Creates a new {Entity} with validation\r\n    /// </summary>\r\n    public virtual async Task<{Entity}> CreateAsync(\r\n        Guid? tenantId,\r\n        string name)\r\n    {\r\n        // Validate input\r\n        Check.NotNullOrWhiteSpace(name, nameof(name));\r\n\r\n        // Check for duplicates or other business rules\r\n        var existing = await _repository.FindByNameAsync(name);\r\n        if (existing != null)\r\n        {\r\n            throw new BusinessException(\"{ServiceName}:{Entity}:NameAlreadyExists\")\r\n                .WithData(\"name\", name);\r\n        }\r\n\r\n        // Create entity\r\n        var entity = new {Entity}(\r\n            id: _guidGenerator.Create(),\r\n            tenantId: tenantId,\r\n            name: name\r\n        );\r\n\r\n        _logger.LogInformation(\"Created {EntityName} with Id {EntityId}\", \r\n            nameof({Entity}), entity.Id);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Updates an existing {Entity}\r\n    /// </summary>\r\n    public virtual async Task<{Entity}> UpdateAsync(\r\n        {Entity} entity,\r\n        string name)\r\n    {\r\n        Check.NotNull(entity, nameof(entity));\r\n        Check.NotNullOrWhiteSpace(name, nameof(name));\r\n\r\n        // Check for duplicates (excluding current entity)\r\n        var existing = await _repository.FindByNameAsync(name);\r\n        if (existing != null && existing.Id != entity.Id)\r\n        {\r\n            throw new BusinessException(\"{ServiceName}:{Entity}:NameAlreadyExists\")\r\n                .WithData(\"name\", name);\r\n        }\r\n\r\n        entity.SetName(name);\r\n\r\n        _logger.LogInformation(\"Updated {EntityName} with Id {EntityId}\", \r\n            nameof({Entity}), entity.Id);\r\n\r\n        return entity;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Validates business rules\r\n    /// </summary>\r\n    public virtual Task ValidateAsync({Entity} entity)\r\n    {\r\n        Check.NotNull(entity, nameof(entity));\r\n        \r\n        // Add validation logic\r\n        \r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n"
          }
        ]
      },
      {
        "fullPath": "skills/abp-framework/abp-entity",
        "filename": "SKILL.md",
        "name": "abp-entity",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-entity\r\ndescription: Creates ABP Framework entities and aggregate roots following QQG conventions. Use this skill when creating new domain entities, aggregate roots, or value objects in the Domain layer.\r\n---\r\n\r\n# ABP Entity Creation\r\n\r\nCreate entities and aggregate roots following ABP Framework best practices and QQG-specific conventions.\r\n\r\n## When to Use This Skill\r\n\r\n- Creating a new aggregate root for a microservice\r\n- Creating child entities within an aggregate\r\n- Creating value objects\r\n- Adding new properties to existing entities\r\n\r\n## Entity Type Decision Tree\r\n\r\n```\r\nIs this the main entry point for a business concept?\r\n├─ Yes → Create as Aggregate Root (inherit FullAuditedAggregateRoot<Guid>)\r\n│         └─ Will other aggregates reference this? → Reference by Id only\r\n└─ No → Is this owned by an aggregate?\r\n    ├─ Yes → Create as Entity (inherit FullAuditedEntity<Guid>)\r\n    └─ No → Create as Value Object (no Id, immutable)\r\n```\r\n\r\n## File Location\r\n\r\n```\r\nDomain/{Feature}/\r\n├── {Entity}.cs                        # Aggregate root\r\n├── {ChildEntity}.cs                   # Child entities\r\n├── {ValueObject}.cs                   # Value objects\r\n├── I{Entity}Repository.cs             # Repository interface\r\n└── {Entity}Manager.cs                 # Domain service (if needed)\r\n```\r\n\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n## Required Steps\r\n\r\n1. **Determine entity location**: `services/{ServiceName}/src/{CompanyName}.{ServiceName}.Domain/{Feature}/`\r\n2. **Choose base class** based on requirements\r\n3. **Implement IMultiTenant** for all entities\r\n4. **Create primary constructor** with validation\r\n5. **Create protected parameterless constructor** for ORM\r\n6. **Define properties with protected setters**\r\n7. **Add to DbContext** in EntityFrameworkCore project\r\n\r\n## File Naming\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Aggregate Root | `{Name}.cs` | `ProcessingEvent.cs` |\r\n| Child Entity | `{Name}.cs` | `ProcessingEventDetail.cs` |\r\n| Value Object | `{Name}.cs` | `GeoLocation.cs` |\r\n\r\n## Template Usage\r\n\r\nUse the templates in this skill folder:\r\n- `aggregate-root-template.cs` - For new aggregate roots\r\n- `entity-template.cs` - For child entities\r\n- `value-object-template.cs` - For value objects\r\n\r\n## QQG-Specific Rules\r\n\r\n1. **Always implement `IMultiTenant`** - All entities must support multi-tenancy\r\n2. **Use `Guid` primary keys** - Never use int/long for aggregate root keys\r\n3. **Reference other aggregates by Id** - Never add navigation properties to other aggregates\r\n4. **Keep aggregates small** - Consider performance when loading/saving\r\n5. **Use `protected set`** for properties - Maintain invariants through methods\r\n\r\n## Validation\r\n\r\nAfter creating an entity:\r\n- [ ] Inherits from correct base class\r\n- [ ] Implements `IMultiTenant` with `TenantId` property\r\n- [ ] Has primary constructor with validation\r\n- [ ] Has protected parameterless constructor\r\n- [ ] Properties use `protected set` or `private set`\r\n- [ ] Collections initialized in constructor\r\n- [ ] No navigation properties to other aggregates",
        "files": [
          {
            "name": "aggregate-root-template.cs",
            "content": "using System;\r\nusing System.Collections.Generic;\r\nusing Volo.Abp.Domain.Entities.Auditing;\r\nusing Volo.Abp.MultiTenancy;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// {Description}\r\n/// </summary>\r\npublic class {EntityName} : FullAuditedAggregateRoot<Guid>, IMultiTenant\r\n{\r\n    public Guid? TenantId { get; protected set; }\r\n\r\n    /// <summary>\r\n    /// {PropertyDescription}\r\n    /// </summary>\r\n    public virtual string Name { get; protected set; } = string.Empty;\r\n\r\n    // Add other properties with protected set\r\n    // public virtual Guid CategoryId { get; protected set; }  // Reference other aggregates by Id only\r\n\r\n    // Collections - always initialize in constructor\r\n    // public virtual ICollection<{ChildEntity}> Items { get; protected set; }\r\n\r\n    /// <summary>\r\n    /// Protected constructor for ORM\r\n    /// </summary>\r\n    protected {EntityName}()\r\n    {\r\n        // Items = new List<{ChildEntity}>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Primary constructor - ensures entity validity on creation\r\n    /// </summary>\r\n    /// <param name=\"id\">Entity Id - use IGuidGenerator to create</param>\r\n    /// <param name=\"tenantId\">Tenant Id</param>\r\n    /// <param name=\"name\">Name</param>\r\n    public {EntityName}(\r\n        Guid id,\r\n        Guid? tenantId,\r\n        string name) : base(id)\r\n    {\r\n        TenantId = tenantId;\r\n        SetName(name);\r\n        // Items = new List<{ChildEntity}>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Sets the name with validation\r\n    /// </summary>\r\n    /// <returns>Entity for fluent API</returns>\r\n    public virtual {EntityName} SetName(string name)\r\n    {\r\n        Name = Check.NotNullOrWhiteSpace(name, nameof(name), maxLength: 256);\r\n        return this;\r\n    }\r\n\r\n    // Add setter methods for other properties\r\n    // public virtual {EntityName} SetCategoryId(Guid categoryId)\r\n    // {\r\n    //     CategoryId = categoryId;\r\n    //     return this;\r\n    // }\r\n}\r\n"
          },
          {
            "name": "entity-template.cs",
            "content": "using System;\r\nusing Volo.Abp.Domain.Entities.Auditing;\r\nusing Volo.Abp.MultiTenancy;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// {Description} - Child entity of {ParentAggregate}\r\n/// </summary>\r\npublic class {EntityName} : FullAuditedEntity<Guid>, IMultiTenant\r\n{\r\n    public Guid? TenantId { get; protected set; }\r\n\r\n    /// <summary>\r\n    /// Parent aggregate root Id\r\n    /// </summary>\r\n    public virtual Guid {ParentName}Id { get; protected set; }\r\n\r\n    /// <summary>\r\n    /// {PropertyDescription}\r\n    /// </summary>\r\n    public virtual string Name { get; protected set; } = string.Empty;\r\n\r\n    // Add other properties with protected set\r\n\r\n    /// <summary>\r\n    /// Protected constructor for ORM\r\n    /// </summary>\r\n    protected {EntityName}()\r\n    {\r\n    }\r\n\r\n    /// <summary>\r\n    /// Primary constructor\r\n    /// </summary>\r\n    public {EntityName}(\r\n        Guid id,\r\n        Guid? tenantId,\r\n        Guid {parentName}Id,\r\n        string name) : base(id)\r\n    {\r\n        TenantId = tenantId;\r\n        {ParentName}Id = {parentName}Id;\r\n        SetName(name);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Sets the name with validation\r\n    /// </summary>\r\n    public virtual {EntityName} SetName(string name)\r\n    {\r\n        Name = Check.NotNullOrWhiteSpace(name, nameof(name), maxLength: 256);\r\n        return this;\r\n    }\r\n}\r\n"
          },
          {
            "name": "value-object-template.cs",
            "content": "using System;\r\nusing Volo.Abp.Domain.Values;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// {Description} - Immutable value object\r\n/// </summary>\r\npublic class {ValueObjectName} : ValueObject\r\n{\r\n    /// <summary>\r\n    /// {PropertyDescription}\r\n    /// </summary>\r\n    public string Property1 { get; }\r\n\r\n    /// <summary>\r\n    /// {PropertyDescription}\r\n    /// </summary>\r\n    public decimal Property2 { get; }\r\n\r\n    /// <summary>\r\n    /// Private constructor for ORM/serialization\r\n    /// </summary>\r\n    private {ValueObjectName}()\r\n    {\r\n        Property1 = string.Empty;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Creates a new {ValueObjectName}\r\n    /// </summary>\r\n    public {ValueObjectName}(string property1, decimal property2)\r\n    {\r\n        Property1 = Check.NotNullOrWhiteSpace(property1, nameof(property1));\r\n        Property2 = property2;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Returns the properties used for equality comparison\r\n    /// </summary>\r\n    protected override IEnumerable<object> GetAtomicValues()\r\n    {\r\n        yield return Property1;\r\n        yield return Property2;\r\n    }\r\n}\r\n"
          }
        ]
      },
      {
        "fullPath": "skills/abp-framework/abp-event-handler",
        "filename": "SKILL.md",
        "name": "abp-event-handler",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-event-handler\r\ndescription: Creates ABP Framework event handlers for local and distributed events following QQG conventions. Use this skill when implementing event-driven patterns, cache invalidation, or cross-service communication.\r\n---\r\n\r\n# ABP Event Handler Creation\r\n\r\nCreate local and distributed event handlers for event-driven architecture.\r\n\r\n## Event Type Decision\r\n\r\n| Type | Use Case | Scope |\r\n|------|----------|-------|\r\n| **Local Event** | Cache invalidation, in-process reactions | Same process only |\r\n| **Distributed Event** | Cross-service communication | Across microservices |\r\n\r\n## Local Events\r\n\r\nFor in-process event handling (same microservice).\r\n\r\n### Common Use Cases\r\n- Cache invalidation on entity changes\r\n- Audit logging\r\n- Triggering background jobs\r\n- Updating denormalized data\r\n\r\n### File Location\r\n```\r\nApplication/{Feature}/\r\n├── {Entity}CreatedUpdatedLocalEventHandler.cs\r\n├── {Entity}CacheInvalidationHandler.cs    # Cache-specific handlers\r\n```\r\n\r\n> Event handlers stay in feature folders with related AppServices\r\n\r\n### Template Files\r\n- `local-event-handler-template.cs` - Local event handler\r\n\r\n## Distributed Events\r\n\r\nFor cross-microservice communication via message broker.\r\n\r\n### Common Use Cases\r\n- Notifying other services of changes\r\n- Saga/choreography patterns\r\n- Integration events\r\n\r\n### Components\r\n1. **ETO (Event Transfer Object)** - Data contract in Contracts project\r\n2. **Handler** - Consumes events from other services\r\n\r\n### File Locations\r\n```\r\nApplication.Contracts/{Feature}/\r\n└── {Event}Eto.cs\r\n\r\nApplication/{Feature}/\r\n└── {Event}Handler.cs\r\n```\r\n\r\n### Template Files\r\n- `distributed-event-handler-template.cs` - Distributed handler + ETO\r\n\r\n## Guidelines\r\n\r\n1. **Use local events for in-process** - Lower overhead than distributed\r\n2. **ETOs in Contracts** - Shared between publisher and consumer\r\n3. **Make handlers idempotent** - Events may be delivered multiple times\r\n4. **Include correlation IDs** - For tracing across services\r\n5. **Keep handlers lightweight** - Queue background jobs for heavy work\r\n\r\n## Validation Checklist\r\n\r\n### Local Event Handler\r\n- [ ] Implements `ILocalEventHandler<T>`\r\n- [ ] Implements `ITransientDependency`\r\n- [ ] Handles `EntityCreatedEventData<T>` or `EntityUpdatedEventData<T>`\r\n\r\n### Distributed Event Handler\r\n- [ ] ETO class has `[EventName(\"...\")]` attribute\r\n- [ ] ETO is in Application.Contracts project\r\n- [ ] Handler implements `IDistributedEventHandler<T>`\r\n- [ ] Handler implements `ITransientDependency`",
        "files": [
          {
            "name": "distributed-event-handler-template.cs",
            "content": "// Template: Distributed Event Handler + ETO\r\n// Location: See file sections below\r\n// Replace: {ServiceName}, {Feature}, {Event}, {Entity}\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.Extensions.Logging;\r\nusing Volo.Abp.DependencyInjection;\r\nusing Volo.Abp.EventBus;\r\nusing Volo.Abp.EventBus.Distributed;\r\nusing Volo.Abp.MultiTenancy;\r\n\r\n// ============================================\r\n// Event Transfer Object (ETO)\r\n// File: services/{ServiceName}/src/QQG.{ServiceName}.Application.Contracts/{Feature}/{Event}Eto.cs\r\n// ============================================\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Event transfer object for {Event}\r\n/// Published when {description}\r\n/// </summary>\r\n[EventName(\"QQG.{ServiceName}.{Event}\")]\r\n[Serializable]\r\npublic class {Event}Eto\r\n{\r\n    /// <summary>\r\n    /// Tenant Id for multi-tenant operations\r\n    /// </summary>\r\n    public Guid? TenantId { get; set; }\r\n\r\n    /// <summary>\r\n    /// Entity Id that triggered the event\r\n    /// </summary>\r\n    public Guid EntityId { get; set; }\r\n\r\n    /// <summary>\r\n    /// Name or identifier for logging\r\n    /// </summary>\r\n    public string EntityName { get; set; } = string.Empty;\r\n\r\n    /// <summary>\r\n    /// When the event occurred\r\n    /// </summary>\r\n    public DateTime OccurredAt { get; set; } = DateTime.UtcNow;\r\n\r\n    // Add other properties as needed\r\n}\r\n\r\n// ============================================\r\n// Distributed Event Handler\r\n// File: services/{ServiceName}/src/QQG.{ServiceName}.Application/{Feature}/{Event}Handler.cs\r\n// ============================================\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Handles distributed {Event} events\r\n/// </summary>\r\npublic class {Event}Handler : IDistributedEventHandler<{Event}Eto>, ITransientDependency\r\n{\r\n    private readonly ILogger<{Event}Handler> _logger;\r\n    private readonly I{Entity}Repository _repository;\r\n    private readonly ICurrentTenant _currentTenant;\r\n\r\n    public {Event}Handler(\r\n        ILogger<{Event}Handler> logger,\r\n        I{Entity}Repository repository,\r\n        ICurrentTenant currentTenant)\r\n    {\r\n        _logger = logger;\r\n        _repository = repository;\r\n        _currentTenant = currentTenant;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Handles the distributed event\r\n    /// </summary>\r\n    public virtual async Task HandleEventAsync({Event}Eto eventData)\r\n    {\r\n        _logger.LogInformation(\"Handling {Event} for entity {EntityId}\",\r\n            nameof({Event}Eto), eventData.EntityId);\r\n\r\n        try\r\n        {\r\n            // Switch to correct tenant context\r\n            using (_currentTenant.Change(eventData.TenantId))\r\n            {\r\n                // Process the event\r\n                // var entity = await _repository.GetAsync(eventData.EntityId);\r\n                // Do something with the entity...\r\n\r\n                _logger.LogInformation(\"Completed handling {Event} for entity {EntityId}\",\r\n                    nameof({Event}Eto), eventData.EntityId);\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            _logger.LogError(ex, \"Error handling {Event} for entity {EntityId}\",\r\n                nameof({Event}Eto), eventData.EntityId);\r\n            throw; // Re-throw to allow retry\r\n        }\r\n    }\r\n}\r\n\r\n// ============================================\r\n// How to Publish a Distributed Event\r\n// ============================================\r\n/*\r\npublic class SomeAppService : ApplicationService\r\n{\r\n    private readonly IDistributedEventBus _distributedEventBus;\r\n\r\n    public SomeAppService(IDistributedEventBus distributedEventBus)\r\n    {\r\n        _distributedEventBus = distributedEventBus;\r\n    }\r\n\r\n    public async Task PublishEventAsync({Entity} entity)\r\n    {\r\n        await _distributedEventBus.PublishAsync(\r\n            new {Event}Eto\r\n            {\r\n                TenantId = CurrentTenant.Id,\r\n                EntityId = entity.Id,\r\n                EntityName = entity.Name,\r\n                OccurredAt = DateTime.UtcNow\r\n            }\r\n        );\r\n    }\r\n}\r\n*/\r\n"
          },
          {
            "name": "local-event-handler-template.cs",
            "content": "// Template: Local Event Handler (Cache Invalidation)\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Application/{Feature}/{Entity}CreatedUpdatedLocalEventHandler.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System.Threading.Tasks;\r\nusing Microsoft.Extensions.Logging;\r\nusing Volo.Abp.DependencyInjection;\r\nusing Volo.Abp.Domain.Entities.Events;\r\nusing Volo.Abp.EventBus;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Handles local entity events for {Entity}\r\n/// Used for cache invalidation when entities are created or updated\r\n/// </summary>\r\npublic class {Entity}CreatedUpdatedLocalEventHandler :\r\n    ILocalEventHandler<EntityCreatedEventData<{Entity}>>,\r\n    ILocalEventHandler<EntityUpdatedEventData<{Entity}>>,\r\n    ILocalEventHandler<EntityDeletedEventData<{Entity}>>,\r\n    ITransientDependency\r\n{\r\n    private readonly I{Entity}CacheService _cacheService;\r\n    private readonly ILogger<{Entity}CreatedUpdatedLocalEventHandler> _logger;\r\n\r\n    public {Entity}CreatedUpdatedLocalEventHandler(\r\n        I{Entity}CacheService cacheService,\r\n        ILogger<{Entity}CreatedUpdatedLocalEventHandler> logger)\r\n    {\r\n        _cacheService = cacheService;\r\n        _logger = logger;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Handles entity created event\r\n    /// </summary>\r\n    public virtual async Task HandleEventAsync(EntityCreatedEventData<{Entity}> eventData)\r\n    {\r\n        _logger.LogDebug(\"{Entity} created with Id {EntityId}, invalidating cache\",\r\n            nameof({Entity}), eventData.Entity.Id);\r\n            \r\n        await _cacheService.InvalidateCacheAsync();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Handles entity updated event\r\n    /// </summary>\r\n    public virtual async Task HandleEventAsync(EntityUpdatedEventData<{Entity}> eventData)\r\n    {\r\n        _logger.LogDebug(\"{Entity} updated with Id {EntityId}, invalidating cache\",\r\n            nameof({Entity}), eventData.Entity.Id);\r\n            \r\n        await _cacheService.InvalidateCacheAsync();\r\n    }\r\n\r\n    /// <summary>\r\n    /// Handles entity deleted event\r\n    /// </summary>\r\n    public virtual async Task HandleEventAsync(EntityDeletedEventData<{Entity}> eventData)\r\n    {\r\n        _logger.LogDebug(\"{Entity} deleted with Id {EntityId}, invalidating cache\",\r\n            nameof({Entity}), eventData.Entity.Id);\r\n            \r\n        await _cacheService.InvalidateCacheAsync();\r\n    }\r\n}\r\n"
          }
        ]
      },
      {
        "fullPath": "skills/abp-framework/abp-folder-structure",
        "filename": "SKILL.md",
        "name": "abp-folder-structure",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-folder-structure\r\ndescription: Defines ABP Framework module folder structure and naming conventions. Use this skill as a reference when organizing code in ABP application modules.\r\n---\r\n\r\n# ABP Module Folder Structure Guidelines\r\n\r\nThis document defines the recommended folder structure for ABP application modules.\r\n\r\n## Domain.Shared Layer Structure\r\n\r\nEnums, constants, and error codes go in Domain.Shared (not Domain) for cross-layer sharing.\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Domain.Shared/\r\n├── {Feature1}/                        # Feature-based folders for enums\r\n│   └── {Entity}Status.cs              # Enums related to feature\r\n├── {Feature2}/\r\n│   └── {Entity}Type.cs\r\n├── {ServiceName}Consts.cs             # Module-level constants\r\n├── {ServiceName}ErrorCodes.cs         # Error codes for exceptions\r\n├── Localization/                      # Localization resources\r\n│   └── {ServiceName}/\r\n└── {ServiceName}DomainSharedModule.cs\r\n```\r\n\r\n## Domain Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Domain/\r\n├── {Feature1}/                        # Feature-based folders\r\n│   ├── {Entity}.cs                    # Aggregate root\r\n│   ├── {ChildEntity}.cs               # Child entities\r\n│   ├── {ValueObject}.cs               # Value objects\r\n│   ├── I{Entity}Repository.cs         # Repository interface\r\n│   └── {Entity}Manager.cs             # Domain service (Manager suffix)\r\n├── {Feature2}/\r\n│   └── ...\r\n└── {ServiceName}DomainModule.cs\r\n```\r\n\r\n## Application Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Application/\r\n├── BackgroundJobs/                    # Root-level for all background jobs\r\n│   ├── {Name}Job.cs\r\n│   └── {Name}Args.cs\r\n├── BackgroundWorkers/                 # Root-level for all background workers\r\n│   └── {Name}Worker.cs\r\n├── {Feature1}/                        # Feature-based folders\r\n│   ├── {Feature1}AppService.cs        # Application service\r\n│   ├── I{Feature1}CacheService.cs     # Cache service interface\r\n│   ├── {Feature1}CacheService.cs      # Cache service implementation\r\n│   ├── {Feature1}EventHandler.cs      # Local/distributed event handlers\r\n│   └── Dtos/                          # DTOs for this feature\r\n│       ├── {Entity}Dto.cs\r\n│       ├── {Entity}DetailDto.cs\r\n│       ├── Create{Entity}Dto.cs\r\n│       ├── Update{Entity}Dto.cs\r\n│       └── Get{Entity}ListInput.cs\r\n├── {Feature2}/\r\n│   └── ...\r\n├── Integrations/                      # Cross-service integration\r\n│   └── {Service}IntegrationAppService.cs\r\n├── Services/                          # Cross-cutting shared services\r\n│   ├── I{Name}Service.cs\r\n│   └── {Name}Service.cs\r\n├── {ServiceName}ApplicationModule.cs\r\n└── {ServiceName}ApplicationAutoMapperProfile.cs\r\n```\r\n\r\n## Application Contracts Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Application.Contracts/\r\n├── {Feature1}/\r\n│   ├── I{Feature1}AppService.cs       # AppService interface\r\n│   ├── {Entity}Dto.cs                 # Output DTOs\r\n│   ├── Create{Entity}Dto.cs           # Input DTOs\r\n│   ├── Update{Entity}Dto.cs\r\n│   └── {Event}Eto.cs                  # Distributed event ETOs\r\n├── {Feature2}/\r\n│   └── ...\r\n├── Permissions/\r\n│   ├── {ServiceName}Permissions.cs\r\n│   └── {ServiceName}PermissionDefinitionProvider.cs\r\n└── {ServiceName}ApplicationContractsModule.cs\r\n```\r\n\r\n## EntityFrameworkCore Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.EntityFrameworkCore/\r\n├── {Feature1}/\r\n│   └── Ef{Entity}Repository.cs        # Repository implementation\r\n├── {ServiceName}DbContext.cs\r\n├── {ServiceName}DbContextModelBuilderExtensions.cs\r\n├── {ServiceName}EntityFrameworkCoreModule.cs\r\n└── EntityFrameworkCore/\r\n    └── Migrations/\r\n```\r\n\r\n## Key Principles\r\n\r\n### 1. Feature-Based Organization\r\n- Group related files by feature/aggregate, not by type\r\n- Each feature folder contains all related files (entities, services, DTOs, handlers)\r\n\r\n### 2. Cross-Cutting Concerns\r\n- `BackgroundJobs/` - Root level, all jobs together\r\n- `BackgroundWorkers/` - Root level, all workers together\r\n- `Services/` - Shared services used across features\r\n- `Integrations/` - Cross-service communication\r\n\r\n### 3. Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Aggregate Root | `{Name}` | `Order`, `Product` |\r\n| Child Entity | `{Name}` | `OrderLine`, `ProductVariant` |\r\n| Repository Interface | `I{Entity}Repository` | `IOrderRepository` |\r\n| Repository Impl | `Ef{Entity}Repository` | `EfOrderRepository` |\r\n| Domain Service | `{Name}Manager` | `OrderManager` |\r\n| AppService Interface | `I{Feature}AppService` | `IOrderAppService` |\r\n| AppService Impl | `{Feature}AppService` | `OrderAppService` |\r\n| Cache Service | `{Entity}CacheService` | `ProductCacheService` |\r\n| Event Handler | `{Entity/Event}Handler` | `OrderCreatedHandler` |\r\n| Background Job | `{Name}Job` | `SendEmailJob` |\r\n| Background Worker | `{Name}Worker` | `CleanupWorker` |\r\n| DTO (Output) | `{Entity}Dto` | `OrderDto` |\r\n| DTO (Create) | `Create{Entity}Dto` | `CreateOrderDto` |\r\n| DTO (Update) | `Update{Entity}Dto` | `UpdateOrderDto` |\r\n| ETO | `{Event}Eto` | `OrderCreatedEto` |\r\n| Enum | `{Entity}{Property}` | `OrderStatus`, `PaymentType` |\r\n| Constants | `{ServiceName}Consts` | `EmployeeServiceConsts` |\r\n| Error Codes | `{ServiceName}ErrorCodes` | `EmployeeServiceErrorCodes` |\r\n\r\n### 4. ABP Official Layer Dependencies\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                      HttpApi.Host                            │\r\n├─────────────────────────────────────────────────────────────┤\r\n│   HttpApi          │    Application    │   EntityFrameworkCore│\r\n├───────────────────┼───────────────────┼─────────────────────┤\r\n│        Application.Contracts          │        Domain        │\r\n├───────────────────────────────────────┼─────────────────────┤\r\n│                    Domain.Shared                             │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n## References\r\n- [ABP Module Architecture Best Practices](https://abp.io/docs/latest/framework/architecture/best-practices/module-architecture)",
        "files": []
      },
      {
        "fullPath": "skills/abp-framework/abp-repository",
        "filename": "SKILL.md",
        "name": "abp-repository",
        "category": "abp-framework",
        "description": "",
        "globs": "",
        "content": "---\r\nname: abp-repository\r\ndescription: Creates ABP Framework repository interfaces and EF Core implementations following QQG conventions. Use this skill when creating custom repositories for entities.\r\n---\r\n\r\n# ABP Repository Creation\r\n\r\nCreate custom repository interfaces and EF Core implementations for entities.\r\n\r\n## When to Use Custom Repositories\r\n\r\n- Need custom query methods beyond basic CRUD\r\n- Complex queries with filtering, sorting, pagination\r\n- Performance-critical operations\r\n- Queries involving multiple entities\r\n\r\n## Required Steps\r\n\r\n1. **Create interface** in Domain: `I{Entity}Repository.cs`\r\n2. **Create implementation** in EntityFrameworkCore: `Ef{Entity}Repository.cs`\r\n3. **Add DbSet** in DbContext if not already present\r\n4. **Configure entity** in DbContext's `OnModelCreating`\r\n\r\n## File Locations\r\n\r\n```bash\r\nDomain/{Feature}/\r\n├── I{Entity}Repository.cs             # Interface (in Domain layer)\r\n\r\nEntityFrameworkCore/{Feature}/\r\n├── Ef{Entity}Repository.cs            # Implementation (in EF layer)\r\n```\r\n\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n## Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Interface | `I{Entity}Repository` | `IProcessingEventRepository` |\r\n| Implementation | `Ef{Entity}Repository` | `EfProcessingEventRepository` |\r\n\r\n## Template Files\r\n\r\n- `repository-interface-template.cs` - Interface definition\r\n- `repository-template.cs` - EF Core implementation\r\n\r\n## Common Query Methods\r\n\r\n```csharp\r\n// Get by unique field (includeDetails=true for single entity)\r\nTask<{Entity}?> FindByNameAsync(\r\n    string name,\r\n    bool includeDetails = true,\r\n    CancellationToken cancellationToken = default);\r\n\r\n// Get list with filters (includeDetails=false for lists)\r\nTask<List<{Entity}>> GetListAsync(\r\n    int skipCount,\r\n    int maxResultCount,\r\n    string? sorting = null,\r\n    string? filter = null,\r\n    bool includeDetails = false,\r\n    CancellationToken cancellationToken = default);\r\n\r\n// Get count\r\nTask<long> GetCountAsync(\r\n    string? filter = null,\r\n    CancellationToken cancellationToken = default);\r\n\r\n// Get with includes\r\nTask<{Entity}> GetWithDetailsAsync(\r\n    Guid id,\r\n    CancellationToken cancellationToken = default);\r\n```\r\n\r\n## ABP Best Practices\r\n\r\n- **Inherit from `IBasicRepository`** - NOT `IRepository` (avoids exposing IQueryable)\r\n- **Add `includeDetails` param** - Default `true` for single, `false` for lists\r\n- **Add `CancellationToken`** - Always optional on all methods\r\n- **Do NOT use IQueryable** - Keep queries inside repository\r\n\r\n## Guidelines\r\n\r\n1. **Interface in Domain** - Implementation in EntityFrameworkCore\r\n2. **Use async methods** - All repository methods should be async\r\n3. **Support cancellation** - Add CancellationToken parameters\r\n4. **Return nullable** for Find methods - Return non-nullable for Get methods (throws if not found)\r\n5. **Inherit from IBasicRepository** - NOT IRepository (avoid IQueryable exposure)\r\n\r\n## Validation Checklist\r\n\r\n- [ ] Interface inherits from `IBasicRepository<{Entity}, Guid>`\r\n- [ ] Implementation inherits from `EfCoreRepository<{DbContext}, {Entity}, Guid>`\r\n- [ ] All methods are async with CancellationToken\r\n- [ ] DbSet added to DbContext\r\n- [ ] Entity configured in OnModelCreating",
        "files": [
          {
            "name": "repository-interface-template.cs",
            "content": "// Template: Repository Interface\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.Domain/{Feature}/I{Entity}Repository.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing Volo.Abp.Domain.Repositories;\r\n\r\nnamespace QQG.{ServiceName}.{Feature};\r\n\r\n/// <summary>\r\n/// Repository interface for {Entity}\r\n/// NOTE: Inherit from IBasicRepository (not IRepository) to avoid exposing IQueryable\r\n/// </summary>\r\npublic interface I{Entity}Repository : IBasicRepository<{Entity}, Guid>\r\n{\r\n    /// <summary>\r\n    /// Finds an entity by name\r\n    /// </summary>\r\n    Task<{Entity}?> FindByNameAsync(\r\n        string name,\r\n        CancellationToken cancellationToken = default);\r\n\r\n    /// <summary>\r\n    /// Gets a paged list of entities\r\n    /// </summary>\r\n    Task<List<{Entity}>> GetListAsync(\r\n        int skipCount,\r\n        int maxResultCount,\r\n        string? sorting = null,\r\n        string? filter = null,\r\n        CancellationToken cancellationToken = default);\r\n\r\n    /// <summary>\r\n    /// Gets the total count\r\n    /// </summary>\r\n    Task<long> GetCountAsync(\r\n        string? filter = null,\r\n        CancellationToken cancellationToken = default);\r\n\r\n    /// <summary>\r\n    /// Gets entity with all related data loaded\r\n    /// </summary>\r\n    Task<{Entity}> GetWithDetailsAsync(\r\n        Guid id,\r\n        CancellationToken cancellationToken = default);\r\n}\r\n"
          },
          {
            "name": "repository-template.cs",
            "content": "// Template: EF Core Repository Implementation\r\n// Location: services/{ServiceName}/src/QQG.{ServiceName}.EntityFrameworkCore/Repositories/Ef{Entity}Repository.cs\r\n// Replace: {ServiceName}, {Feature}, {Entity}, {DbContext}\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Linq.Dynamic.Core;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.EntityFrameworkCore;\r\nusing Volo.Abp.Domain.Repositories.EntityFrameworkCore;\r\nusing Volo.Abp.EntityFrameworkCore;\r\n\r\nnamespace QQG.{ServiceName}.EntityFrameworkCore.Repositories;\r\n\r\n/// <summary>\r\n/// EF Core repository implementation for {Entity}\r\n/// </summary>\r\npublic class Ef{Entity}Repository \r\n    : EfCoreRepository<{ServiceName}DbContext, {Entity}, Guid>, \r\n      I{Entity}Repository\r\n{\r\n    public Ef{Entity}Repository(\r\n        IDbContextProvider<{ServiceName}DbContext> dbContextProvider)\r\n        : base(dbContextProvider)\r\n    {\r\n    }\r\n\r\n    /// <summary>\r\n    /// Finds an entity by name\r\n    /// NOTE: Use GetCancellationToken helper per ABP best practices\r\n    /// </summary>\r\n    public virtual async Task<{Entity}?> FindByNameAsync(\r\n        string name,\r\n        bool includeDetails = true,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        var dbSet = await GetDbSetAsync();\r\n        return await dbSet\r\n            .IncludeDetails(includeDetails)\r\n            .FirstOrDefaultAsync(x => x.Name == name, GetCancellationToken(cancellationToken));\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets a paged list of entities\r\n    /// </summary>\r\n    public virtual async Task<List<{Entity}>> GetListAsync(\r\n        int skipCount,\r\n        int maxResultCount,\r\n        string? sorting = null,\r\n        string? filter = null,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        var dbSet = await GetDbSetAsync();\r\n        \r\n        return await dbSet\r\n            .WhereIf(!string.IsNullOrWhiteSpace(filter),\r\n                x => x.Name.Contains(filter!))\r\n            .OrderBy(sorting.IsNullOrWhiteSpace() ? nameof({Entity}.Name) : sorting)\r\n            .Skip(skipCount)\r\n            .Take(maxResultCount)\r\n            .ToListAsync(cancellationToken);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets the total count\r\n    /// </summary>\r\n    public virtual async Task<long> GetCountAsync(\r\n        string? filter = null,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        var dbSet = await GetDbSetAsync();\r\n        \r\n        return await dbSet\r\n            .WhereIf(!string.IsNullOrWhiteSpace(filter),\r\n                x => x.Name.Contains(filter!))\r\n            .LongCountAsync(cancellationToken);\r\n    }\r\n\r\n    /// <summary>\r\n    /// Gets entity with all related data loaded\r\n    /// </summary>\r\n    public virtual async Task<{Entity}> GetWithDetailsAsync(\r\n        Guid id,\r\n        CancellationToken cancellationToken = default)\r\n    {\r\n        var dbSet = await GetDbSetAsync();\r\n        \r\n        return await dbSet\r\n            // .Include(x => x.RelatedEntity)\r\n            .FirstAsync(x => x.Id == id, cancellationToken);\r\n    }\r\n}\r\n"
          }
        ]
      }
    ]
  }
}