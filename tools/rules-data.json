{
  "frontend": [
    {
      "path": "frontend/typescript",
      "name": "typescript",
      "category": "frontend",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: TypeScript coding standards and best practices for modern development. Apply when writing TypeScript code in any project.\r\nglobs: \"**/*.ts, **/*.tsx, **/*.d.ts\"\r\n---\r\n\r\n# TypeScript Best Practices\r\n\r\n## Type System\r\n\r\n- Prefer `interface` over `type` for object definitions\r\n- Use `type` for unions, intersections, and mapped types\r\n- **Avoid `any`** - prefer `unknown` for unknown types\r\n- Enable strict mode in `tsconfig.json`\r\n- Leverage built-in utility types (`Partial`, `Required`, `Pick`, `Omit`, `Record`)\r\n\r\n## Naming Conventions\r\n\r\n| Type | Convention | Example |\r\n|------|------------|---------|\r\n| Interface/Type | PascalCase | `UserProfile`, `ApiResponse` |\r\n| Variable/Function | camelCase | `getUserData`, `isLoading` |\r\n| Constant | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `API_BASE_URL` |\r\n| Enum values | PascalCase | `UserRole.Admin` |\r\n\r\n## Functions\r\n\r\n```typescript\r\n// Explicit return type for public functions\r\nexport function calculateTotal(items: CartItem[]): number {\r\n  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\r\n}\r\n\r\n// Arrow function with proper typing\r\nconst formatDate = (date: Date, locale: string = 'en-US'): string => {\r\n  return new Intl.DateTimeFormat(locale).format(date);\r\n};\r\n```\r\n\r\n## Best Practices\r\n\r\n- Use `readonly` for immutable properties\r\n- Leverage discriminated unions for type safety\r\n- Use type guards for runtime type checking\r\n- Implement proper null checking with `?.` and `??`\r\n- Avoid type assertions (`as`) unless necessary\r\n\r\n## Configuration\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"noImplicitAny\": true,\r\n    \"strictNullChecks\": true,\r\n    \"noImplicitReturns\": true\r\n  }\r\n}\r\n```"
    },
    {
      "path": "frontend/uniapp",
      "name": "uniapp",
      "category": "frontend",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: UniApp development guidelines for cross-platform mobile/mini-program applications. Apply when developing with UniApp framework.\r\nglobs: \"**/*.vue, **/pages/**/*.vue, **/components/**/*.vue, manifest.json, pages.json\"\r\n---\r\n\r\n# UniApp Development Guidelines\r\n\r\n## Overview\r\n\r\nUniApp is a cross-platform framework that allows you to develop once and deploy to:\r\n- **H5** (Web)\r\n- **WeChat/Alipay/Baidu Mini Programs**\r\n- **iOS/Android Apps**\r\n\r\n## Project Structure\r\n\r\n```\r\n├── pages/                 # Page components\r\n│   └── index/\r\n│       └── index.vue\r\n├── components/            # Reusable components\r\n├── static/               # Static assets (images, fonts)\r\n├── store/                # Vuex/Pinia store\r\n├── utils/                # Utility functions\r\n├── api/                  # API request modules\r\n├── uni_modules/          # UniApp plugins\r\n├── App.vue               # App entry component\r\n├── main.js               # Entry file\r\n├── manifest.json         # App configuration\r\n├── pages.json            # Page routing configuration\r\n└── uni.scss              # Global SCSS variables\r\n```\r\n\r\n## Vue 3 Composition API (UniApp 3.x)\r\n\r\n```vue\r\n<script setup>\r\nimport { ref, computed, onMounted } from 'vue'\r\n\r\nconst count = ref(0)\r\nconst doubleCount = computed(() => count.value * 2)\r\n\r\nonMounted(() => {\r\n  console.log('Page mounted')\r\n})\r\n\r\n// UniApp lifecycle hooks\r\nonLoad((options) => {\r\n  console.log('Page loaded with options:', options)\r\n})\r\n\r\nonShow(() => {\r\n  console.log('Page shown')\r\n})\r\n</script>\r\n```\r\n\r\n## Responsive Design (rpx)\r\n\r\n```scss\r\n// Use rpx for responsive units (750rpx = screen width)\r\n.container {\r\n  width: 750rpx;      // Full width\r\n  padding: 30rpx;     // ~15px on 375px screen\r\n  font-size: 28rpx;   // ~14px on 375px screen\r\n}\r\n```\r\n\r\n## Platform-Specific Code\r\n\r\n```vue\r\n<template>\r\n  <view>\r\n    <!-- #ifdef MP-WEIXIN -->\r\n    <button open-type=\"getUserInfo\">微信登录</button>\r\n    <!-- #endif -->\r\n    \r\n    <!-- #ifdef H5 -->\r\n    <button @click=\"h5Login\">H5登录</button>\r\n    <!-- #endif -->\r\n    \r\n    <!-- #ifdef APP-PLUS -->\r\n    <button @click=\"appLogin\">App登录</button>\r\n    <!-- #endif -->\r\n  </view>\r\n</template>\r\n```\r\n\r\n## Navigation\r\n\r\n```javascript\r\nuni.navigateTo({ url: '/pages/detail/detail?id=123' })\r\nuni.redirectTo({ url: '/pages/login/login' })\r\nuni.switchTab({ url: '/pages/index/index' })\r\nuni.navigateBack({ delta: 1 })\r\n```\r\n\r\n## Common UI Patterns\r\n\r\n```javascript\r\nuni.showLoading({ title: '加载中...' })\r\nuni.hideLoading()\r\n\r\nuni.showToast({ title: '操作成功', icon: 'success' })\r\n\r\nuni.showModal({\r\n  title: '提示',\r\n  content: '确定要删除吗？',\r\n  success: (res) => {\r\n    if (res.confirm) { /* confirmed */ }\r\n  }\r\n})\r\n```\r\n\r\n## Best Practices\r\n\r\n1. **Use rpx** for responsive sizing (750rpx = full screen width)\r\n2. **Use conditional compilation** (`#ifdef`) for platform-specific code\r\n3. **Check component support** in UniApp docs before using\r\n4. **Handle API errors** with proper user feedback\r\n5. **Use uni-ui** components for cross-platform compatibility\r\n6. **Test on multiple platforms** (WeChat DevTools, H5, App simulator)\r\n7. **Avoid direct DOM manipulation** - use data binding\r\n8. **Use pages.json** for page configuration"
    }
  ],
  "general": [
    {
      "path": "general/clean-code",
      "name": "clean-code",
      "category": "general",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: Clean code principles for writing maintainable and human-readable code. Apply during code writing and review.\r\nglobs: \"**/*\"\r\n---\r\n\r\n# Clean Code Guidelines\r\n\r\n## Constants Over Magic Numbers\r\n\r\n```typescript\r\n// Bad\r\nif (retryCount > 3) { }\r\nconst timeout = 86400000\r\n\r\n// Good\r\nconst MAX_RETRY_COUNT = 3\r\nconst ONE_DAY_MS = 24 * 60 * 60 * 1000\r\n\r\nif (retryCount > MAX_RETRY_COUNT) { }\r\nconst timeout = ONE_DAY_MS\r\n```\r\n\r\n## Meaningful Names\r\n\r\n```typescript\r\n// Bad\r\nconst d = new Date()\r\nconst u = users.filter(x => x.a)\r\n\r\n// Good\r\nconst createdDate = new Date()\r\nconst activeUsers = users.filter(user => user.isActive)\r\n```\r\n\r\n## Single Responsibility\r\n\r\n- Each function should do exactly one thing\r\n- Functions should be small and focused\r\n- If a function needs a comment to explain what it does, split it\r\n\r\n## DRY (Don't Repeat Yourself)\r\n\r\n- Extract repeated code into reusable functions\r\n- Share common logic through proper abstraction\r\n- Maintain single sources of truth\r\n\r\n## Smart Comments\r\n\r\n- Don't comment what code does - make code self-documenting\r\n- Comment **why** something is done a certain way\r\n- Document APIs and non-obvious side effects\r\n\r\n## Encapsulation\r\n\r\n- Hide implementation details\r\n- Expose clear interfaces\r\n- Move nested conditionals into well-named functions\r\n\r\n## Checklist\r\n\r\n- [ ] No magic numbers - use named constants\r\n- [ ] All names are meaningful and descriptive\r\n- [ ] Comments explain \"why\" not \"what\"\r\n- [ ] Each function has single responsibility\r\n- [ ] No repeated code - DRY principle followed"
    },
    {
      "path": "general/coding-standards",
      "name": "coding-standards",
      "category": "general",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: General coding standards and guidelines. Apply to all code reviews and development tasks.\r\nglobs: \"**/*\"\r\n---\r\n\r\n# Coding Standards\r\n\r\n## Core Principles\r\n\r\n- **Verify information** before presenting it\r\n- **Preserve existing code** - don't remove unrelated code\r\n- **Use explicit variable names** - prefer descriptive over short\r\n- **Follow existing coding style** - maintain consistency\r\n- **Consider security** - always think about security implications\r\n- **Handle edge cases** - consider and handle potential edge cases\r\n\r\n## AI Agent Behavior Rules\r\n\r\n### Do's\r\n- Make changes file by file\r\n- Provide all edits in a single chunk per file\r\n- Use explicit, descriptive variable names\r\n- Follow consistent coding style\r\n- Include appropriate unit tests\r\n- Implement robust error handling\r\n\r\n### Don'ts\r\n- No apologies in code or comments\r\n- No whitespace-only changes unless requested\r\n- No unnecessary confirmations of provided information\r\n- No inventions beyond what's explicitly requested\r\n- No summaries unless asked\r\n- No implementation discussions unless requested\r\n\r\n## Performance\r\n\r\n```typescript\r\n// Use early returns\r\nfunction processItem(item: Item | null): Result {\r\n  if (!item) return null\r\n  if (!item.isValid) return null\r\n  return process(item)\r\n}\r\n\r\n// Use appropriate data structures\r\nconst userMap = new Map<string, User>()  // O(1) lookup\r\nconst uniqueIds = new Set<string>()       // O(1) membership\r\n```\r\n\r\n## Documentation\r\n\r\n- Don't comment **what** - make code self-documenting\r\n- Comment **why** something is done a certain way\r\n- Document APIs and non-obvious side effects\r\n\r\n## Version Control\r\n\r\n- Write clear, descriptive commit messages\r\n- Make small, focused commits\r\n- Use meaningful branch names\r\n\r\n## Checklist\r\n\r\n- [ ] No magic numbers or strings\r\n- [ ] Meaningful variable and function names\r\n- [ ] Functions have single responsibility\r\n- [ ] No code duplication\r\n- [ ] Proper error handling\r\n- [ ] Edge cases considered\r\n- [ ] Tests included for new functionality"
    },
    {
      "path": "general/git-workflow",
      "name": "git-workflow",
      "category": "general",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: Git workflow, branching strategy, and commit conventions. Apply when working with version control.\r\nglobs: \".git/**, .gitignore, CHANGELOG.md\"\r\n---\r\n\r\n# Git Workflow & Conventions\r\n\r\n## Branch Strategy (Gitflow)\r\n\r\n| Branch | Purpose | Rules |\r\n|--------|---------|-------|\r\n| `main` | Production-ready code | Never commit directly |\r\n| `develop` | Latest development changes | Never commit directly |\r\n\r\n### Supporting Branches\r\n\r\n| Type | Branch From | Merge To | Example |\r\n|------|-------------|----------|---------|\r\n| Feature | develop | develop | `feature/123-user-auth` |\r\n| Release | develop | main, develop | `release/v1.2.0` |\r\n| Hotfix | main | main, develop | `hotfix/v1.2.1` |\r\n\r\n## Commit Message Convention\r\n\r\n```\r\n<type>(<scope>): <description>\r\n\r\n[optional body]\r\n\r\n[optional footer(s)]\r\n```\r\n\r\n### Types\r\n\r\n| Type | Description |\r\n|------|-------------|\r\n| `feat` | New feature |\r\n| `fix` | Bug fix |\r\n| `docs` | Documentation changes |\r\n| `style` | Formatting, no code change |\r\n| `refactor` | Code refactoring |\r\n| `perf` | Performance improvement |\r\n| `test` | Adding/updating tests |\r\n| `chore` | Maintenance tasks |\r\n\r\n### Examples\r\n\r\n```bash\r\nfeat(auth): add OAuth2 login support\r\nfix(cart): resolve quantity calculation error\r\nfeat(api)!: change response format for user endpoint\r\n\r\nBREAKING CHANGE: Response now wraps data in 'result' field\r\n```\r\n\r\n## Semantic Versioning\r\n\r\n```\r\nMAJOR.MINOR.PATCH\r\n\r\n1.0.0 → 1.0.1  (PATCH: bug fix)\r\n1.0.1 → 1.1.0  (MINOR: new feature)\r\n1.1.0 → 2.0.0  (MAJOR: breaking changes)\r\n```\r\n\r\n## Pull Request Rules\r\n\r\n1. All changes must go through Pull Requests\r\n2. Minimum 1 approval required\r\n3. CI checks must pass\r\n4. Branch must be up to date before merging\r\n5. Delete branch after merge"
    }
  ],
  "testing": [
    {
      "path": "testing/playwright",
      "name": "playwright",
      "category": "testing",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: Playwright E2E testing best practices. Apply when writing end-to-end tests with Playwright.\r\nglobs: \"**/*.spec.ts, **/e2e/**/*.ts, playwright.config.ts\"\r\n---\r\n\r\n# Playwright E2E Testing\r\n\r\n## Best Practices\r\n\r\n1. **Descriptive Names** - Use test names that explain behavior\r\n2. **Proper Setup** - Include setup in test.beforeEach blocks\r\n3. **Selector Usage** - Use data-testid over CSS/XPath selectors\r\n4. **Waiting Strategy** - Leverage Playwright's auto-waiting\r\n5. **Mock Dependencies** - Mock external dependencies with page.route\r\n6. **Validation Coverage** - Validate both success and error scenarios\r\n7. **Test Focus** - Limit test files to 3-5 focused tests\r\n\r\n## Test Pattern\r\n\r\n```typescript\r\nimport { test, expect } from '@playwright/test'\r\n\r\ntest.describe('Login Page', () => {\r\n  test.beforeEach(async ({ page }) => {\r\n    // Mock API responses\r\n    await page.route('/api/login', (route) => {\r\n      const body = route.request().postDataJSON()\r\n      if (body.username === 'valid' && body.password === 'valid') {\r\n        route.fulfill({\r\n          status: 200,\r\n          body: JSON.stringify({ token: 'abc123' })\r\n        })\r\n      } else {\r\n        route.fulfill({\r\n          status: 401,\r\n          body: JSON.stringify({ error: 'Invalid credentials' })\r\n        })\r\n      }\r\n    })\r\n    \r\n    await page.goto('/login')\r\n  })\r\n\r\n  test('should login successfully with valid credentials', async ({ page }) => {\r\n    await page.locator('[data-testid=\"username\"]').fill('valid')\r\n    await page.locator('[data-testid=\"password\"]').fill('valid')\r\n    await page.locator('[data-testid=\"submit\"]').click()\r\n    \r\n    await expect(page).toHaveURL('/dashboard')\r\n    await expect(page.locator('[data-testid=\"welcome\"]')).toBeVisible()\r\n  })\r\n\r\n  test('should show error for invalid credentials', async ({ page }) => {\r\n    await page.locator('[data-testid=\"username\"]').fill('invalid')\r\n    await page.locator('[data-testid=\"password\"]').fill('wrong')\r\n    await page.locator('[data-testid=\"submit\"]').click()\r\n    \r\n    await expect(page.locator('[data-testid=\"error\"]')).toHaveText('Invalid credentials')\r\n  })\r\n})\r\n```\r\n\r\n## Selectors\r\n\r\n```typescript\r\n// Preferred: data-testid\r\npage.locator('[data-testid=\"submit-button\"]')\r\n\r\n// Semantic selectors\r\npage.getByRole('button', { name: 'Submit' })\r\npage.getByLabel('Email')\r\npage.getByText('Welcome')\r\n\r\n// Avoid: CSS selectors\r\npage.locator('.btn-primary')  // fragile\r\n```\r\n\r\n## Checklist\r\n\r\n- [ ] Use data-testid selectors\r\n- [ ] Mock API responses for isolation\r\n- [ ] Test both success and error paths\r\n- [ ] Use proper waiting (auto-wait preferred)\r\n- [ ] Keep tests independent"
    },
    {
      "path": "testing/vitest",
      "name": "vitest",
      "category": "testing",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: Vitest unit testing best practices. Apply when writing unit tests with Vitest.\r\nglobs: \"**/*.test.ts, **/*.spec.ts, vitest.config.ts\"\r\n---\r\n\r\n# Vitest Unit Testing\r\n\r\n## Best Practices\r\n\r\n1. **Critical Functionality First** - Prioritize testing business logic\r\n2. **Mock Dependencies** - Always mock external dependencies\r\n3. **Test Data Scenarios** - Test valid, invalid inputs, and edge cases\r\n4. **Descriptive Naming** - Use clear test names\r\n5. **Test Organization** - Group related tests in describe blocks\r\n6. **Focused Tests** - Limit to 3-5 focused tests per file\r\n\r\n## Test Pattern\r\n\r\n```typescript\r\nimport { describe, it, expect, beforeEach, vi } from 'vitest'\r\n\r\n// Mock dependencies before imports\r\nvi.mock('../api/userService', () => ({\r\n  fetchUser: vi.fn()\r\n}))\r\n\r\nimport { fetchUser } from '../api/userService'\r\nimport { getUserDisplayName } from '../utils/userUtils'\r\n\r\ndescribe('getUserDisplayName', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks()\r\n  })\r\n\r\n  it('should return full name when both names exist', () => {\r\n    // Arrange\r\n    const user = { firstName: 'John', lastName: 'Doe' }\r\n    \r\n    // Act\r\n    const result = getUserDisplayName(user)\r\n    \r\n    // Assert\r\n    expect(result).toBe('John Doe')\r\n  })\r\n\r\n  it('should throw error for null input', () => {\r\n    expect(() => getUserDisplayName(null)).toThrow('User is required')\r\n  })\r\n\r\n  it('should handle undefined properties gracefully', () => {\r\n    const user = {}\r\n    const result = getUserDisplayName(user)\r\n    expect(result).toBe('Unknown User')\r\n  })\r\n})\r\n```\r\n\r\n## Async Testing\r\n\r\n```typescript\r\nit('should fetch user data successfully', async () => {\r\n  const mockUser = { id: '1', name: 'John' }\r\n  ;(fetchUser as any).mockResolvedValue(mockUser)\r\n  \r\n  const result = await getUserData('1')\r\n  \r\n  expect(fetchUser).toHaveBeenCalledWith('1')\r\n  expect(result).toEqual(mockUser)\r\n})\r\n\r\nit('should handle API errors gracefully', async () => {\r\n  ;(fetchUser as any).mockRejectedValue(new Error('Network error'))\r\n  \r\n  await expect(getUserData('1')).rejects.toThrow('Failed to fetch user')\r\n})\r\n```\r\n\r\n## Checklist\r\n\r\n- [ ] Tests follow AAA pattern (Arrange, Act, Assert)\r\n- [ ] Each test has a single assertion focus\r\n- [ ] Dependencies are properly mocked\r\n- [ ] Test names clearly describe behavior\r\n- [ ] Edge cases and error scenarios covered"
    },
    {
      "path": "testing/vue-test-utils",
      "name": "vue-test-utils",
      "category": "testing",
      "description": "",
      "globs": "",
      "content": "---\r\ndescription: Vue Test Utils component testing best practices. Apply when testing Vue components.\r\nglobs: \"**/*.test.ts, **/*.spec.ts, **/components/**/*.test.ts\"\r\n---\r\n\r\n# Vue Component Testing\r\n\r\n## Setup\r\n\r\n```typescript\r\nimport { mount } from '@vue/test-utils'\r\nimport { createTestingPinia } from '@pinia/testing'\r\nimport { vi } from 'vitest'\r\nimport UserCard from './UserCard.vue'\r\n\r\ndescribe('UserCard', () => {\r\n  const createWrapper = (props = {}, options = {}) => {\r\n    return mount(UserCard, {\r\n      props: {\r\n        user: { id: '1', name: 'John Doe' },\r\n        ...props\r\n      },\r\n      global: {\r\n        plugins: [createTestingPinia({ createSpy: vi.fn })],\r\n        ...options.global\r\n      }\r\n    })\r\n  }\r\n```\r\n\r\n## Testing Patterns\r\n\r\n### Props and Rendering\r\n\r\n```typescript\r\nit('displays user name', () => {\r\n  const wrapper = createWrapper()\r\n  expect(wrapper.text()).toContain('John Doe')\r\n})\r\n\r\nit('shows loading state when isLoading is true', () => {\r\n  const wrapper = createWrapper({ isLoading: true })\r\n  expect(wrapper.find('[data-testid=\"loading\"]').exists()).toBe(true)\r\n})\r\n```\r\n\r\n### Events\r\n\r\n```typescript\r\nit('emits select event when clicked', async () => {\r\n  const wrapper = createWrapper()\r\n  await wrapper.find('[data-testid=\"user-card\"]').trigger('click')\r\n  \r\n  expect(wrapper.emitted('select')).toHaveLength(1)\r\n  expect(wrapper.emitted('select')[0]).toEqual([{ id: '1', name: 'John Doe' }])\r\n})\r\n```\r\n\r\n### Store Interaction\r\n\r\n```typescript\r\nit('calls store action on submit', async () => {\r\n  const wrapper = createWrapper()\r\n  const store = useUserStore()\r\n  \r\n  await wrapper.find('form').trigger('submit')\r\n  \r\n  expect(store.updateUser).toHaveBeenCalled()\r\n})\r\n```\r\n\r\n### Async Operations\r\n\r\n```typescript\r\nit('displays data after async load', async () => {\r\n  const wrapper = createWrapper()\r\n  \r\n  // Wait for async operations\r\n  await flushPromises()\r\n  \r\n  expect(wrapper.find('[data-testid=\"data\"]').exists()).toBe(true)\r\n})\r\n```\r\n\r\n## Checklist\r\n\r\n- [ ] Test component rendering\r\n- [ ] Test props handling\r\n- [ ] Test event emission\r\n- [ ] Test store interactions\r\n- [ ] Test async operations\r\n- [ ] Mock external dependencies"
    }
  ],
  "skills": [
    {
      "path": "skills/abp-framework/abp-application-service",
      "name": "abp-application-service",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-application-service\r\ndescription: Creates ABP Framework application services following QQG conventions. Use this skill when implementing CRUD operations, API endpoints, or coordinating domain operations from the Application layer.\r\n---\r\n\r\n# ABP Application Service Creation\r\n\r\nCreate application services for API endpoints following ABP Framework patterns and QQG conventions.\r\n\r\n## When to Use This Skill\r\n\r\n- Creating CRUD operations for an aggregate root\r\n- Implementing API endpoints\r\n- Coordinating domain services and repositories\r\n- Mapping between DTOs and entities\r\n\r\n## Required Steps\r\n\r\n1. **Create interface** in Application.Contracts: `I{Feature}AppService.cs`\r\n2. **Create DTOs** in Application.Contracts: `{Entity}Dto.cs`, `Create{Entity}Dto.cs`, etc.\r\n3. **Create implementation** in Application: `{Feature}AppService.cs`\r\n4. **Add AutoMapper mappings** in `{ServiceName}ApplicationAutoMapperProfile.cs`\r\n\r\n## File Locations\r\n\r\n```\r\nApplication.Contracts/{Feature}/\r\n├── I{Feature}AppService.cs            # Interface\r\n├── {Entity}Dto.cs                     # Output DTOs\r\n├── Create{Entity}Dto.cs               # Input DTOs\r\n└── Update{Entity}Dto.cs\r\n\r\nApplication/{Feature}/\r\n├── {Feature}AppService.cs             # Implementation\r\n├── I{Entity}CacheService.cs           # Optional cache service\r\n├── {Entity}CacheService.cs\r\n└── Dtos/                              # Feature-specific DTOs (if not in Contracts)\r\n```\r\n\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n## Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Interface | `I{Feature}AppService` | `IProcessingEventAppService` |\r\n| Implementation | `{Feature}AppService` | `ProcessingEventAppService` |\r\n| Basic DTO | `{Entity}Dto` | `ProcessingEventDto` |\r\n| Create DTO | `Create{Entity}Dto` | `CreateProcessingEventDto` |\r\n| Update DTO | `Update{Entity}Dto` | `UpdateProcessingEventDto` |\r\n| List Input | `Get{Entity}ListInput` | `GetProcessingEventListInput` |\r\n\r\n## Template Files\r\n\r\n- `appservice-interface-template.cs` - Interface in Contracts\r\n- `appservice-template.cs` - Implementation\r\n- `dto-templates.cs` - DTO examples\r\n\r\n## Guidelines\r\n\r\n1. **One AppService per aggregate root**\r\n2. **Never return entities** - Always use DTOs\r\n3. **Use custom repositories** - Not generic `IRepository<T>`\r\n4. **Make all public methods virtual** - For extensibility\r\n5. **Make private methods protected virtual** - Allow override\r\n6. **Inherit from ApplicationService** base class\r\n7. **Use ObjectMapper** for entity-DTO mapping\r\n8. **Call repository Update** after entity changes - Not all DBs auto-track\r\n\r\n## Cross-Service Communication\r\n\r\n- **Do NOT** call other AppServices in **same** module - Use domain layer\r\n- **May** call AppServices from **other** modules via contracts only\r\n- **Use** domain services for complex business logic\r\n\r\n## Validation Checklist\r\n\r\n- [ ] Interface defined in Application.Contracts\r\n- [ ] DTOs created with proper validation attributes\r\n- [ ] Implementation inherits from `ApplicationService`\r\n- [ ] Custom repository injected (not generic)\r\n- [ ] AutoMapper profile updated\r\n- [ ] All public methods are `virtual`"
    },
    {
      "path": "skills/abp-framework/abp-background-worker",
      "name": "abp-background-worker",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-background-worker\r\ndescription: Creates ABP Framework background workers and background jobs following QQG conventions. Use this skill when implementing periodic tasks, queued jobs, or async processing.\r\n---\r\n\r\n# ABP Background Worker & Job Creation\r\n\r\nCreate background workers (periodic tasks) and background jobs (queued one-time tasks).\r\n\r\n## Worker vs Job Decision\r\n\r\n| Type | Use Case | Execution |\r\n|------|----------|-----------|\r\n| **Background Worker** | Polling, cleanup, recovery | Runs periodically on timer |\r\n| **Background Job** | Emails, logging, async tasks | Queued, executed once |\r\n\r\n## Background Workers\r\n\r\nPeriodic tasks that run in the background on a timer.\r\n\r\n### When to Use\r\n- Periodic cleanup tasks\r\n- Scheduled data sync\r\n- Health checks\r\n- Cache refresh\r\n\r\n### File Location\r\n```\r\nApplication/\r\n├── BackgroundWorkers/                 # Root-level folder for ALL workers\r\n│   ├── {Name}Worker.cs\r\n│   └── {Name}Configuration.cs         # Optional worker config\r\n```\r\n\r\n> **Note**: Workers go in a root-level `BackgroundWorkers/` folder, NOT in feature folders\r\n\r\n### Template Files\r\n- `worker-template.cs` - Worker implementation\r\n- `worker-configuration-template.cs` - Configuration class\r\n\r\n### Registration\r\nRegister in HttpApi.Host module's `OnApplicationInitializationAsync`:\r\n```csharp\r\nawait context.AddBackgroundWorkerAsync<{Name}Worker>();\r\n```\r\n\r\n## Background Jobs\r\n\r\nOne-time tasks that are queued and executed asynchronously.\r\n\r\n### When to Use Jobs\r\n- Sending emails/notifications\r\n- Recording audit logs asynchronously\r\n- Tasks that can be retried on failure\r\n- Long-running operations\r\n\r\n### File Location\r\n```\r\nApplication/\r\n├── BackgroundJobs/                    # Root-level folder for ALL jobs\r\n│   ├── {Name}Job.cs\r\n│   └── {Name}Args.cs\r\n```\r\n\r\n> **Note**: Jobs go in a root-level `BackgroundJobs/` folder, NOT in feature folders\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n### Template Files\r\n- `job-template.cs` - Job implementation with Args class\r\n\r\n### Queuing a Job\r\n```csharp\r\nawait _backgroundJobManager.EnqueueAsync(new {Name}Args { ... });\r\n```\r\n\r\n## ABP Official Guidelines\r\n\r\n### Background Workers\r\n1. **Resolve dependencies from `workerContext.ServiceProvider`** - NOT constructor injection\r\n2. **Worker uses `IServiceScope`** - Disposed when work finishes\r\n3. **Exceptions are auto-caught and logged** by `AsyncPeriodicBackgroundWorkerBase`\r\n4. **Register in `OnApplicationInitializationAsync`** - Use `context.AddBackgroundWorkerAsync<T>()`\r\n5. **Consider clustered deployment** - Use distributed lock if needed\r\n\r\n### Background Jobs\r\n1. **Use `AsyncBackgroundJob<TArgs>`** - For async operations\r\n2. **Jobs auto-retry on exception** - Hide exception only if no retry needed\r\n3. **Use `ICancellationTokenProvider`** - For cancellable jobs\r\n4. **Use `[BackgroundJobName]` attribute** - For custom job naming\r\n5. **Include TenantId in args** - For multi-tenant operations\r\n\r\n## Validation Checklist\r\n\r\n### Worker\r\n- [ ] Inherits from `AsyncPeriodicBackgroundWorkerBase`\r\n- [ ] Has `[UnitOfWork]` attribute\r\n- [ ] Resolves scoped services from `workerContext.ServiceProvider`\r\n- [ ] Registered in HttpApi.Host module\r\n\r\n### Job\r\n- [ ] Inherits from `AsyncBackgroundJob<{Name}Args>` (for async operations)\r\n- [ ] Implements `ITransientDependency`\r\n- [ ] Args class has `[Serializable]` attribute\r\n- [ ] Args includes `TenantId` for multi-tenancy\r\n- [ ] Uses `ICancellationTokenProvider` if cancellable"
    },
    {
      "path": "skills/abp-framework/abp-cache-service",
      "name": "abp-cache-service",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-cache-service\r\ndescription: Creates ABP Framework cache services following QQG conventions. Use this skill when implementing distributed caching for entities or data that needs to be cached for performance.\r\n---\r\n\r\n# ABP Cache Service Creation\r\n\r\nCreate cache services for efficient data access using ABP's distributed caching system.\r\n\r\n## When to Use Cache Services\r\n\r\n- Frequently accessed data that rarely changes\r\n- Expensive database queries or calculations\r\n- Data shared across requests/users\r\n- Reducing database load\r\n\r\n## Required Components\r\n\r\n1. **Cache Item Class** - DTO-like class for cached data\r\n2. **Cache Service Interface** - `I{Entity}CacheService`\r\n3. **Cache Service Implementation** - Uses `IDistributedCache<T>`\r\n4. **Event Handler** - Invalidates cache on entity changes\r\n\r\n## File Locations\r\n\r\n```\r\nApplication/\r\n├── {Feature}/\r\n│   ├── I{Entity}CacheService.cs\r\n│   ├── {Entity}CacheService.cs\r\n│   └── {Entity}CacheItem.cs (if separate from DTO)\r\n```\r\n\r\n## Template Files\r\n\r\n- `cache-service-interface-template.cs` - Interface definition\r\n- `cache-service-template.cs` - Implementation with ABP patterns\r\n- `cache-item-template.cs` - Cache item class\r\n\r\n## ABP Cache Features\r\n\r\n### Key Features\r\n- **Auto serialization/deserialization** - JSON by default\r\n- **Auto tenant isolation** - TenantId added to cache key\r\n- **Error tolerance** - Errors hidden by default, falls back to source\r\n- **Batch operations** - `GetManyAsync`, `SetManyAsync`\r\n- **Unit of Work integration** - `considerUow` parameter\r\n\r\n### Cache Key Best Practices\r\n- Use `[CacheName(\"MyCache\")]` attribute for custom cache names\r\n- Use `[IgnoreMultiTenancy]` if cache shared across tenants\r\n- Configure `KeyPrefix` for multi-app environments\r\n\r\n### Important Methods\r\n```csharp\r\n// Get or add with factory\r\nawait _cache.GetOrAddAsync(key, factory, options);\r\n\r\n// Batch operations\r\nawait _cache.GetManyAsync(keys);\r\nawait _cache.SetManyAsync(items);\r\n\r\n// Remove\r\nawait _cache.RemoveAsync(key);\r\n```\r\n\r\n## Cache Invalidation Pattern\r\n\r\nAlways invalidate cache when entity changes:\r\n1. Create local event handler for entity events\r\n2. Call `InvalidateCacheAsync()` on create/update/delete\r\n\r\n## ABP Official Guidelines\r\n\r\n1. **Use `IDistributedCache<T>`** - NOT standard `IDistributedCache`\r\n2. **Use `GetOrAddAsync`** - Factory pattern for cache miss\r\n3. **Set appropriate expiration** - `AbsoluteExpiration` or `SlidingExpiration`\r\n4. **Consider `considerUow: true`** - For transactional consistency\r\n5. **Handle batch operations** - Use `GetManyAsync`/`SetManyAsync`\r\n\r\n---\r\n\r\n## Entity Cache (Built-in Auto-Invalidation)\r\n\r\nABP provides a simpler `IEntityCache<T, TKey>` for caching entities with **automatic invalidation** on update/delete.\r\n\r\n### Registration\r\n```csharp\r\n// In module ConfigureServices\r\n// Option 1: Cache entity directly\r\ncontext.Services.AddEntityCache<Product, Guid>();\r\n\r\n// Option 2: Cache as DTO (requires AutoMapper config)\r\ncontext.Services.AddEntityCache<Product, ProductDto, Guid>();\r\n\r\n// With custom expiration\r\ncontext.Services.AddEntityCache<Product, ProductDto, Guid>(\r\n    new DistributedCacheEntryOptions \r\n    { \r\n        SlidingExpiration = TimeSpan.FromMinutes(30) \r\n    }\r\n);\r\n```\r\n\r\n### Usage\r\n```csharp\r\npublic class ProductAppService : ApplicationService\r\n{\r\n    private readonly IEntityCache<ProductDto, Guid> _productCache;\r\n\r\n    public ProductAppService(IEntityCache<ProductDto, Guid> productCache)\r\n    {\r\n        _productCache = productCache;\r\n    }\r\n\r\n    public async Task<ProductDto> GetAsync(Guid id)\r\n    {\r\n        // Auto-fetches from DB on first call, then from cache\r\n        // Auto-invalidates when entity is updated/deleted\r\n        return await _productCache.GetAsync(id);\r\n    }\r\n}\r\n```\r\n\r\n### Important Notes\r\n- **Read-only** - Use repository for updates, not entity cache\r\n- **Auto-invalidation** - No manual invalidation needed\r\n- **Default 2 min expiration** - Configure via `DistributedCacheEntryOptions`\r\n- Requires entity to be JSON-serializable (or use DTO)\r\n\r\n### Limitations & When NOT to Use Entity Cache\r\n\r\n| Limitation | Description | Solution |\r\n|------------|-------------|----------|\r\n| **Single entity only** | Only caches by primary key (GetAsync(id)) | Use custom cache for lists |\r\n| **No child entity tracking** | Child entity changes don't invalidate parent | Use custom cache + event handlers |\r\n| **No includeDetails** | Repository fetch may not include children | Custom cache with explicit includes |\r\n| **No collection caching** | Cannot cache `GetListAsync()` results | Use `IDistributedCache<List<T>>` |\r\n| **No composite keys** | Only supports single key lookups | Use custom cache with string keys |\r\n| **No query caching** | Cannot cache filtered/sorted results | Use custom cache service |\r\n\r\n### ⚠️ Critical: Child Entities NOT Included by Default\r\n\r\nWhen `IEntityCache` fetches an entity from the repository, it uses the default repository behavior which **may not include child entities** (navigation properties).\r\n\r\n```csharp\r\n// IEntityCache internally calls repository like this:\r\nvar entity = await _repository.GetAsync(id);  // No includeDetails!\r\n\r\n// Child collections will be EMPTY in cache!\r\n// order.OrderLines = [] (empty!)\r\n```\r\n\r\n**Solution**: For entities with children, use **Custom Cache Service** with explicit includes:\r\n\r\n```csharp\r\npublic class OrderCacheService : IOrderCacheService, ITransientDependency\r\n{\r\n    private readonly IOrderRepository _repository;\r\n    private readonly IDistributedCache<OrderDto, Guid> _cache;\r\n\r\n    public async Task<OrderDto> GetWithDetailsAsync(Guid id)\r\n    {\r\n        return await _cache.GetOrAddAsync(\r\n            id,\r\n            async () =>\r\n            {\r\n                // Explicitly include children!\r\n                var order = await _repository.GetAsync(id, includeDetails: true);\r\n                // OR use custom repository method\r\n                // var order = await _repository.GetWithLinesAsync(id);\r\n                \r\n                return ObjectMapper.Map<Order, OrderDto>(order);\r\n            }\r\n        );\r\n    }\r\n}\r\n```\r\n\r\n### When to Use Entity Cache vs Custom Cache\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────────┐\r\n│                    Which Cache Pattern?                          │\r\n├─────────────────────────────────────────────────────────────────┤\r\n│                                                                  │\r\n│  Need to cache single entity by ID?                             │\r\n│    ├── YES, entity has NO child collections → IEntityCache ✓   │\r\n│    ├── YES, but has child entities → Custom Cache + Events     │\r\n│    └── NO → Custom Cache Service                                │\r\n│                                                                  │\r\n│  Need to cache lists/collections?                               │\r\n│    └── Always use Custom Cache Service                          │\r\n│                                                                  │\r\n│  Need to cache grouped/filtered data?                           │\r\n│    └── Always use Custom Cache Service                          │\r\n│                                                                  │\r\n│  Child entity changes should invalidate cache?                  │\r\n│    └── Custom Cache + Handle child entity events                │\r\n│                                                                  │\r\n└─────────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Example: Caching Entity with Children (Custom Cache Required)\r\n\r\n```csharp\r\n// Order has OrderLines - IEntityCache won't work properly\r\n// Because OrderLine changes won't invalidate Order cache\r\n\r\npublic class OrderCacheService : IOrderCacheService, ITransientDependency\r\n{\r\n    private readonly IDistributedCache<OrderWithLinesDto, Guid> _cache;\r\n    \r\n    // Must handle BOTH Order and OrderLine events\r\n}\r\n\r\n// Event handler for cache invalidation\r\npublic class OrderCacheInvalidationHandler :\r\n    ILocalEventHandler<EntityChangedEventData<Order>>,\r\n    ILocalEventHandler<EntityChangedEventData<OrderLine>>,  // Child!\r\n    ITransientDependency\r\n{\r\n    private readonly IOrderCacheService _cacheService;\r\n    \r\n    public async Task HandleEventAsync(EntityChangedEventData<Order> e)\r\n        => await _cacheService.InvalidateCacheAsync(e.Entity.Id);\r\n    \r\n    public async Task HandleEventAsync(EntityChangedEventData<OrderLine> e)\r\n        => await _cacheService.InvalidateCacheAsync(e.Entity.OrderId);  // Parent ID!\r\n}\r\n```\r\n\r\n### Example: Caching Groups/Lists (Custom Cache Required)\r\n\r\n```csharp\r\n// IEntityCache cannot cache \"all active products\" or \"products by category\"\r\n// Use custom cache with meaningful keys\r\n\r\npublic class ProductCacheService : IProductCacheService, ITransientDependency\r\n{\r\n    private readonly IDistributedCache<List<ProductDto>> _listCache;\r\n    \r\n    private string GetCategoryKey(Guid categoryId) \r\n        => $\"Products:Category:{categoryId}\";\r\n    \r\n    private const string ActiveProductsKey = \"Products:Active:All\";\r\n    \r\n    public async Task<List<ProductDto>> GetByCategoryAsync(Guid categoryId)\r\n    {\r\n        return await _listCache.GetOrAddAsync(\r\n            GetCategoryKey(categoryId),\r\n            async () => await LoadFromDatabase(categoryId),\r\n            () => new DistributedCacheEntryOptions { ... }\r\n        );\r\n    }\r\n    \r\n    // Must invalidate ALL related cache keys on product change\r\n    public async Task InvalidateCacheAsync(Product product)\r\n    {\r\n        await _listCache.RemoveAsync(GetCategoryKey(product.CategoryId));\r\n        await _listCache.RemoveAsync(ActiveProductsKey);\r\n    }\r\n}\r\n```\r\n\r\n---\r\n\r\n## Validation Checklist\r\n\r\n### Custom Cache Service\r\n- [ ] Cache item class defined (or reusing DTO)\r\n- [ ] Interface with `GetAsync` and `InvalidateCacheAsync` methods\r\n- [ ] Implementation uses `IDistributedCache<T>`\r\n- [ ] Uses `GetOrAddAsync` for cache-aside pattern\r\n- [ ] Expiration options configured\r\n- [ ] Event handler created for cache invalidation\r\n- [ ] Implements `ITransientDependency`\r\n\r\n### Entity Cache (Simpler)\r\n- [ ] `AddEntityCache<T, TKey>()` registered in module\r\n- [ ] AutoMapper configured if using DTO\r\n- [ ] Entity is JSON-serializable\r\n- [ ] Use repository for writes (cache is read-only)"
    },
    {
      "path": "skills/abp-framework/abp-domain-service",
      "name": "abp-domain-service",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-domain-service\r\ndescription: Creates ABP Framework domain services and managers following QQG conventions. Use this skill when implementing business logic that spans multiple entities or requires complex domain operations.\r\n---\r\n\r\n# ABP Domain Service Creation\r\n\r\nCreate domain services (managers) for complex business logic following ABP Framework patterns.\r\n\r\n## When to Use Domain Services\r\n\r\nUse a domain service when:\r\n- Business logic spans **multiple aggregate roots**\r\n- Logic requires **external service calls** (other microservices, APIs)\r\n- **Complex calculations** that don't belong to a single entity\r\n- Operations that need **repository access** beyond a single aggregate\r\n\r\n## Do NOT Use Domain Services When\r\n\r\n- Logic belongs to a single entity → Put it in the entity itself\r\n- Simple CRUD operations → Use application services directly\r\n- Cross-cutting concerns → Use interceptors or middleware\r\n\r\n## Required Steps\r\n\r\n1. **Create implementation** in Domain project: `{Name}Manager.cs`\r\n2. **Inherit from `DomainService`** base class\r\n3. **Inject dependencies** (repositories, other domain services)\r\n4. *(Optional)* Create interface only if needed for testing/mocking\r\n\r\n> **Note**: ABP recommends NOT creating interfaces for domain services unless needed for testing.\r\n\r\n## File Location\r\n\r\n```\r\nservices/{ServiceName}/src/QQG.{ServiceName}.Domain/{Feature}/\r\n├── I{Name}Manager.cs\r\n└── {Name}Manager.cs\r\n```\r\n\r\n## Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Interface | `I{Name}Manager` | `IProcessingEventManager` |\r\n| Implementation | `{Name}Manager` | `ProcessingEventManager` |\r\n\r\n## Template Files\r\n\r\n- `domain-service-interface-template.cs` - Interface definition\r\n- `domain-service-template.cs` - Implementation\r\n\r\n## Guidelines\r\n\r\n1. **Keep domain services focused** - One responsibility per service\r\n2. **Do NOT define GET methods** - Use repository directly in AppService for reads\r\n3. **Define methods that mutate data** - Change entity state only\r\n4. **Use self-explanatory names** - Like `AssignToAsync`, not `UpdateAsync`\r\n5. **Accept valid domain objects** - Pass entities, not DTOs\r\n6. **Use Check class** for validation - `Check.NotNull()`, `Check.NotNullOrWhiteSpace()`\r\n7. **Throw BusinessException** - With domain error codes for localization\r\n8. **Make methods virtual** for extensibility\r\n9. **Do NOT return DTOs** - Return domain objects only\r\n\r\n## Validation Checklist\r\n\r\n- [ ] Interface defined with clear method signatures\r\n- [ ] Implementation inherits from `DomainService`\r\n- [ ] Implements `ITransientDependency`\r\n- [ ] All methods are `virtual`\r\n- [ ] Proper exception handling\r\n- [ ] Logging added for key operations"
    },
    {
      "path": "skills/abp-framework/abp-entity",
      "name": "abp-entity",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-entity\r\ndescription: Creates ABP Framework entities and aggregate roots following QQG conventions. Use this skill when creating new domain entities, aggregate roots, or value objects in the Domain layer.\r\n---\r\n\r\n# ABP Entity Creation\r\n\r\nCreate entities and aggregate roots following ABP Framework best practices and QQG-specific conventions.\r\n\r\n## When to Use This Skill\r\n\r\n- Creating a new aggregate root for a microservice\r\n- Creating child entities within an aggregate\r\n- Creating value objects\r\n- Adding new properties to existing entities\r\n\r\n## Entity Type Decision Tree\r\n\r\n```\r\nIs this the main entry point for a business concept?\r\n├─ Yes → Create as Aggregate Root (inherit FullAuditedAggregateRoot<Guid>)\r\n│         └─ Will other aggregates reference this? → Reference by Id only\r\n└─ No → Is this owned by an aggregate?\r\n    ├─ Yes → Create as Entity (inherit FullAuditedEntity<Guid>)\r\n    └─ No → Create as Value Object (no Id, immutable)\r\n```\r\n\r\n## File Location\r\n\r\n```\r\nDomain/{Feature}/\r\n├── {Entity}.cs                        # Aggregate root\r\n├── {ChildEntity}.cs                   # Child entities\r\n├── {ValueObject}.cs                   # Value objects\r\n├── I{Entity}Repository.cs             # Repository interface\r\n└── {Entity}Manager.cs                 # Domain service (if needed)\r\n```\r\n\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n## Required Steps\r\n\r\n1. **Determine entity location**: `services/{ServiceName}/src/{CompanyName}.{ServiceName}.Domain/{Feature}/`\r\n2. **Choose base class** based on requirements\r\n3. **Implement IMultiTenant** for all entities\r\n4. **Create primary constructor** with validation\r\n5. **Create protected parameterless constructor** for ORM\r\n6. **Define properties with protected setters**\r\n7. **Add to DbContext** in EntityFrameworkCore project\r\n\r\n## File Naming\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Aggregate Root | `{Name}.cs` | `ProcessingEvent.cs` |\r\n| Child Entity | `{Name}.cs` | `ProcessingEventDetail.cs` |\r\n| Value Object | `{Name}.cs` | `GeoLocation.cs` |\r\n\r\n## Template Usage\r\n\r\nUse the templates in this skill folder:\r\n- `aggregate-root-template.cs` - For new aggregate roots\r\n- `entity-template.cs` - For child entities\r\n- `value-object-template.cs` - For value objects\r\n\r\n## QQG-Specific Rules\r\n\r\n1. **Always implement `IMultiTenant`** - All entities must support multi-tenancy\r\n2. **Use `Guid` primary keys** - Never use int/long for aggregate root keys\r\n3. **Reference other aggregates by Id** - Never add navigation properties to other aggregates\r\n4. **Keep aggregates small** - Consider performance when loading/saving\r\n5. **Use `protected set`** for properties - Maintain invariants through methods\r\n\r\n## Validation\r\n\r\nAfter creating an entity:\r\n- [ ] Inherits from correct base class\r\n- [ ] Implements `IMultiTenant` with `TenantId` property\r\n- [ ] Has primary constructor with validation\r\n- [ ] Has protected parameterless constructor\r\n- [ ] Properties use `protected set` or `private set`\r\n- [ ] Collections initialized in constructor\r\n- [ ] No navigation properties to other aggregates"
    },
    {
      "path": "skills/abp-framework/abp-event-handler",
      "name": "abp-event-handler",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-event-handler\r\ndescription: Creates ABP Framework event handlers for local and distributed events following QQG conventions. Use this skill when implementing event-driven patterns, cache invalidation, or cross-service communication.\r\n---\r\n\r\n# ABP Event Handler Creation\r\n\r\nCreate local and distributed event handlers for event-driven architecture.\r\n\r\n## Event Type Decision\r\n\r\n| Type | Use Case | Scope |\r\n|------|----------|-------|\r\n| **Local Event** | Cache invalidation, in-process reactions | Same process only |\r\n| **Distributed Event** | Cross-service communication | Across microservices |\r\n\r\n## Local Events\r\n\r\nFor in-process event handling (same microservice).\r\n\r\n### Common Use Cases\r\n- Cache invalidation on entity changes\r\n- Audit logging\r\n- Triggering background jobs\r\n- Updating denormalized data\r\n\r\n### File Location\r\n```\r\nApplication/{Feature}/\r\n├── {Entity}CreatedUpdatedLocalEventHandler.cs\r\n├── {Entity}CacheInvalidationHandler.cs    # Cache-specific handlers\r\n```\r\n\r\n> Event handlers stay in feature folders with related AppServices\r\n\r\n### Template Files\r\n- `local-event-handler-template.cs` - Local event handler\r\n\r\n## Distributed Events\r\n\r\nFor cross-microservice communication via message broker.\r\n\r\n### Common Use Cases\r\n- Notifying other services of changes\r\n- Saga/choreography patterns\r\n- Integration events\r\n\r\n### Components\r\n1. **ETO (Event Transfer Object)** - Data contract in Contracts project\r\n2. **Handler** - Consumes events from other services\r\n\r\n### File Locations\r\n```\r\nApplication.Contracts/{Feature}/\r\n└── {Event}Eto.cs\r\n\r\nApplication/{Feature}/\r\n└── {Event}Handler.cs\r\n```\r\n\r\n### Template Files\r\n- `distributed-event-handler-template.cs` - Distributed handler + ETO\r\n\r\n## Guidelines\r\n\r\n1. **Use local events for in-process** - Lower overhead than distributed\r\n2. **ETOs in Contracts** - Shared between publisher and consumer\r\n3. **Make handlers idempotent** - Events may be delivered multiple times\r\n4. **Include correlation IDs** - For tracing across services\r\n5. **Keep handlers lightweight** - Queue background jobs for heavy work\r\n\r\n## Validation Checklist\r\n\r\n### Local Event Handler\r\n- [ ] Implements `ILocalEventHandler<T>`\r\n- [ ] Implements `ITransientDependency`\r\n- [ ] Handles `EntityCreatedEventData<T>` or `EntityUpdatedEventData<T>`\r\n\r\n### Distributed Event Handler\r\n- [ ] ETO class has `[EventName(\"...\")]` attribute\r\n- [ ] ETO is in Application.Contracts project\r\n- [ ] Handler implements `IDistributedEventHandler<T>`\r\n- [ ] Handler implements `ITransientDependency`"
    },
    {
      "path": "skills/abp-framework/abp-folder-structure",
      "name": "abp-folder-structure",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-folder-structure\r\ndescription: Defines ABP Framework module folder structure and naming conventions. Use this skill as a reference when organizing code in ABP application modules.\r\n---\r\n\r\n# ABP Module Folder Structure Guidelines\r\n\r\nThis document defines the recommended folder structure for ABP application modules.\r\n\r\n## Domain.Shared Layer Structure\r\n\r\nEnums, constants, and error codes go in Domain.Shared (not Domain) for cross-layer sharing.\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Domain.Shared/\r\n├── {Feature1}/                        # Feature-based folders for enums\r\n│   └── {Entity}Status.cs              # Enums related to feature\r\n├── {Feature2}/\r\n│   └── {Entity}Type.cs\r\n├── {ServiceName}Consts.cs             # Module-level constants\r\n├── {ServiceName}ErrorCodes.cs         # Error codes for exceptions\r\n├── Localization/                      # Localization resources\r\n│   └── {ServiceName}/\r\n└── {ServiceName}DomainSharedModule.cs\r\n```\r\n\r\n## Domain Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Domain/\r\n├── {Feature1}/                        # Feature-based folders\r\n│   ├── {Entity}.cs                    # Aggregate root\r\n│   ├── {ChildEntity}.cs               # Child entities\r\n│   ├── {ValueObject}.cs               # Value objects\r\n│   ├── I{Entity}Repository.cs         # Repository interface\r\n│   └── {Entity}Manager.cs             # Domain service (Manager suffix)\r\n├── {Feature2}/\r\n│   └── ...\r\n└── {ServiceName}DomainModule.cs\r\n```\r\n\r\n## Application Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Application/\r\n├── BackgroundJobs/                    # Root-level for all background jobs\r\n│   ├── {Name}Job.cs\r\n│   └── {Name}Args.cs\r\n├── BackgroundWorkers/                 # Root-level for all background workers\r\n│   └── {Name}Worker.cs\r\n├── {Feature1}/                        # Feature-based folders\r\n│   ├── {Feature1}AppService.cs        # Application service\r\n│   ├── I{Feature1}CacheService.cs     # Cache service interface\r\n│   ├── {Feature1}CacheService.cs      # Cache service implementation\r\n│   ├── {Feature1}EventHandler.cs      # Local/distributed event handlers\r\n│   └── Dtos/                          # DTOs for this feature\r\n│       ├── {Entity}Dto.cs\r\n│       ├── {Entity}DetailDto.cs\r\n│       ├── Create{Entity}Dto.cs\r\n│       ├── Update{Entity}Dto.cs\r\n│       └── Get{Entity}ListInput.cs\r\n├── {Feature2}/\r\n│   └── ...\r\n├── Integrations/                      # Cross-service integration\r\n│   └── {Service}IntegrationAppService.cs\r\n├── Services/                          # Cross-cutting shared services\r\n│   ├── I{Name}Service.cs\r\n│   └── {Name}Service.cs\r\n├── {ServiceName}ApplicationModule.cs\r\n└── {ServiceName}ApplicationAutoMapperProfile.cs\r\n```\r\n\r\n## Application Contracts Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.Application.Contracts/\r\n├── {Feature1}/\r\n│   ├── I{Feature1}AppService.cs       # AppService interface\r\n│   ├── {Entity}Dto.cs                 # Output DTOs\r\n│   ├── Create{Entity}Dto.cs           # Input DTOs\r\n│   ├── Update{Entity}Dto.cs\r\n│   └── {Event}Eto.cs                  # Distributed event ETOs\r\n├── {Feature2}/\r\n│   └── ...\r\n├── Permissions/\r\n│   ├── {ServiceName}Permissions.cs\r\n│   └── {ServiceName}PermissionDefinitionProvider.cs\r\n└── {ServiceName}ApplicationContractsModule.cs\r\n```\r\n\r\n## EntityFrameworkCore Layer Structure\r\n\r\n```\r\n{CompanyName}.{ServiceName}.EntityFrameworkCore/\r\n├── {Feature1}/\r\n│   └── Ef{Entity}Repository.cs        # Repository implementation\r\n├── {ServiceName}DbContext.cs\r\n├── {ServiceName}DbContextModelBuilderExtensions.cs\r\n├── {ServiceName}EntityFrameworkCoreModule.cs\r\n└── EntityFrameworkCore/\r\n    └── Migrations/\r\n```\r\n\r\n## Key Principles\r\n\r\n### 1. Feature-Based Organization\r\n- Group related files by feature/aggregate, not by type\r\n- Each feature folder contains all related files (entities, services, DTOs, handlers)\r\n\r\n### 2. Cross-Cutting Concerns\r\n- `BackgroundJobs/` - Root level, all jobs together\r\n- `BackgroundWorkers/` - Root level, all workers together\r\n- `Services/` - Shared services used across features\r\n- `Integrations/` - Cross-service communication\r\n\r\n### 3. Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Aggregate Root | `{Name}` | `Order`, `Product` |\r\n| Child Entity | `{Name}` | `OrderLine`, `ProductVariant` |\r\n| Repository Interface | `I{Entity}Repository` | `IOrderRepository` |\r\n| Repository Impl | `Ef{Entity}Repository` | `EfOrderRepository` |\r\n| Domain Service | `{Name}Manager` | `OrderManager` |\r\n| AppService Interface | `I{Feature}AppService` | `IOrderAppService` |\r\n| AppService Impl | `{Feature}AppService` | `OrderAppService` |\r\n| Cache Service | `{Entity}CacheService` | `ProductCacheService` |\r\n| Event Handler | `{Entity/Event}Handler` | `OrderCreatedHandler` |\r\n| Background Job | `{Name}Job` | `SendEmailJob` |\r\n| Background Worker | `{Name}Worker` | `CleanupWorker` |\r\n| DTO (Output) | `{Entity}Dto` | `OrderDto` |\r\n| DTO (Create) | `Create{Entity}Dto` | `CreateOrderDto` |\r\n| DTO (Update) | `Update{Entity}Dto` | `UpdateOrderDto` |\r\n| ETO | `{Event}Eto` | `OrderCreatedEto` |\r\n| Enum | `{Entity}{Property}` | `OrderStatus`, `PaymentType` |\r\n| Constants | `{ServiceName}Consts` | `EmployeeServiceConsts` |\r\n| Error Codes | `{ServiceName}ErrorCodes` | `EmployeeServiceErrorCodes` |\r\n\r\n### 4. ABP Official Layer Dependencies\r\n\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                      HttpApi.Host                            │\r\n├─────────────────────────────────────────────────────────────┤\r\n│   HttpApi          │    Application    │   EntityFrameworkCore│\r\n├───────────────────┼───────────────────┼─────────────────────┤\r\n│        Application.Contracts          │        Domain        │\r\n├───────────────────────────────────────┼─────────────────────┤\r\n│                    Domain.Shared                             │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n## References\r\n- [ABP Module Architecture Best Practices](https://abp.io/docs/latest/framework/architecture/best-practices/module-architecture)"
    },
    {
      "path": "skills/abp-framework/abp-repository",
      "name": "abp-repository",
      "category": "abp-framework",
      "description": "",
      "globs": "",
      "content": "---\r\nname: abp-repository\r\ndescription: Creates ABP Framework repository interfaces and EF Core implementations following QQG conventions. Use this skill when creating custom repositories for entities.\r\n---\r\n\r\n# ABP Repository Creation\r\n\r\nCreate custom repository interfaces and EF Core implementations for entities.\r\n\r\n## When to Use Custom Repositories\r\n\r\n- Need custom query methods beyond basic CRUD\r\n- Complex queries with filtering, sorting, pagination\r\n- Performance-critical operations\r\n- Queries involving multiple entities\r\n\r\n## Required Steps\r\n\r\n1. **Create interface** in Domain: `I{Entity}Repository.cs`\r\n2. **Create implementation** in EntityFrameworkCore: `Ef{Entity}Repository.cs`\r\n3. **Add DbSet** in DbContext if not already present\r\n4. **Configure entity** in DbContext's `OnModelCreating`\r\n\r\n## File Locations\r\n\r\n```bash\r\nDomain/{Feature}/\r\n├── I{Entity}Repository.cs             # Interface (in Domain layer)\r\n\r\nEntityFrameworkCore/{Feature}/\r\n├── Ef{Entity}Repository.cs            # Implementation (in EF layer)\r\n```\r\n\r\n> See `abp-folder-structure` skill for complete module structure\r\n\r\n## Naming Conventions\r\n\r\n| Type | Pattern | Example |\r\n|------|---------|---------|\r\n| Interface | `I{Entity}Repository` | `IProcessingEventRepository` |\r\n| Implementation | `Ef{Entity}Repository` | `EfProcessingEventRepository` |\r\n\r\n## Template Files\r\n\r\n- `repository-interface-template.cs` - Interface definition\r\n- `repository-template.cs` - EF Core implementation\r\n\r\n## Common Query Methods\r\n\r\n```csharp\r\n// Get by unique field (includeDetails=true for single entity)\r\nTask<{Entity}?> FindByNameAsync(\r\n    string name,\r\n    bool includeDetails = true,\r\n    CancellationToken cancellationToken = default);\r\n\r\n// Get list with filters (includeDetails=false for lists)\r\nTask<List<{Entity}>> GetListAsync(\r\n    int skipCount,\r\n    int maxResultCount,\r\n    string? sorting = null,\r\n    string? filter = null,\r\n    bool includeDetails = false,\r\n    CancellationToken cancellationToken = default);\r\n\r\n// Get count\r\nTask<long> GetCountAsync(\r\n    string? filter = null,\r\n    CancellationToken cancellationToken = default);\r\n\r\n// Get with includes\r\nTask<{Entity}> GetWithDetailsAsync(\r\n    Guid id,\r\n    CancellationToken cancellationToken = default);\r\n```\r\n\r\n## ABP Best Practices\r\n\r\n- **Inherit from `IBasicRepository`** - NOT `IRepository` (avoids exposing IQueryable)\r\n- **Add `includeDetails` param** - Default `true` for single, `false` for lists\r\n- **Add `CancellationToken`** - Always optional on all methods\r\n- **Do NOT use IQueryable** - Keep queries inside repository\r\n\r\n## Guidelines\r\n\r\n1. **Interface in Domain** - Implementation in EntityFrameworkCore\r\n2. **Use async methods** - All repository methods should be async\r\n3. **Support cancellation** - Add CancellationToken parameters\r\n4. **Return nullable** for Find methods - Return non-nullable for Get methods (throws if not found)\r\n5. **Inherit from IBasicRepository** - NOT IRepository (avoid IQueryable exposure)\r\n\r\n## Validation Checklist\r\n\r\n- [ ] Interface inherits from `IBasicRepository<{Entity}, Guid>`\r\n- [ ] Implementation inherits from `EfCoreRepository<{DbContext}, {Entity}, Guid>`\r\n- [ ] All methods are async with CancellationToken\r\n- [ ] DbSet added to DbContext\r\n- [ ] Entity configured in OnModelCreating"
    }
  ]
}